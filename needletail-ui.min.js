import { Client as Client$1 } from '@needletail/js';
import Mustache from 'mustache';
import _debounce from 'lodash/debounce';

class WidgetCollection {
    constructor(client) {
        /**
         * @type {AutocompleteBar[]} All the autocomplete bar widgets
         */
        this.autocompleteBar = [];
        /**
         * @type {GroupedSearchBar[]} All the grouped search bar widgets
         */
        this.groupedSearchBar = [];
        /**
         * @type {Result[]} All the result widgets
         */
        this.result = [];
        /**
         * @type {AggregationBar[]} All the aggregation bar widgets
         */
        this.aggregationBar = [];
        this.client = client;
    }
    add(widget) {
        switch (widget.discriminator) {
            case 'AutocompleteBar':
                this.autocompleteBar.push(widget);
                break;
            case 'GroupedSearchBar':
                this.groupedSearchBar.push(widget);
                break;
            case 'Result':
                this.result.push(widget);
                break;
            case 'AggregationBar':
                this.aggregationBar.push(widget);
                break;
            default:
                // If the widget does not have an array throw an error
                console.error(widget);
                throw new Error('Unsupported widget: ' + widget.discriminator);
        }
        widget.setClient(this.client)
            .build();
    }
    addMultiple(widgets) {
        widgets.forEach((widget) => {
            this.add(widget);
        });
    }
}

class Client extends Client$1 {
    constructor(readKey, baseUrl = null) {
        super(readKey, baseUrl);
        this.widgets = new WidgetCollection(this);
    }
    /**
     * Add a widget to the client
     * @param {WidgetOptions} widget
     * @return {Client}
     */
    addWidget(widget) {
        this.widgets.add(widget);
        return this;
    }
    /**
     * Add multiple widgets at the same time
     * @param {WidgetOptions[]} widgets
     * @return {Client}
     */
    addMultipleWidgets(widgets) {
        this.widgets.addMultiple(widgets);
        return this;
    }
}

var template$7 = "<div class=\"needletail-aggregation needletail-aggregation-switch needletail-aggregation-switch-{{ class_title }} {{ collapsible }} {{ collapsed }}\">\n    <div class=\"needletail-aggregation-switch-title\">\n        {{ title }}\n    </div>\n    <div class=\"needletail-collapsible-container\">\n        <span class=\"needletail-aggregation-boolean-label\">{{ off_value }}</span>\n        <label class=\"needletail-aggregation-switch-container\">\n            <input type=\"checkbox\" name=\"{{ name }}\" value=\"{{ value }}\" class=\"needletail-aggregation-switch-input needletail-aggregation-switch-input-{{ name }}\">\n            <span class=\"needletail-aggregation-switch-slider\"></span>\n        </label>\n        <span class=\"needletail-aggregation-boolean-label\">{{ on_value }}</span>\n    </div>\n</div>";

var skeletonTemplate$3 = "<div class=\"needletail-aggregation needletail-aggregation-switch needletail-aggregation-switch-{{ class_title }}\">\n    <div class=\"needletail-skeleton needletail-skeleton-spacing needletail-skeleton-spacing--l\">\n        <h3 class=\"needletail-skeleton-header\">\n            <span class=\"needletail-skeleton-box\" style=\"width:25%;\"></span>\n        </h3>\n        <span class=\"needletail-skeleton-box\" style=\"width:40%;\"></span>\n    </div>\n</div>\n";

class URIHelper {
    static addToHistory(name, value, deleteOnExist = false) {
        const currentUrl = new URL(window.location.href);
        if (deleteOnExist && currentUrl.searchParams.has(name)) {
            const values = currentUrl.searchParams.getAll(name);
            const index = values.indexOf(String(value));
            if (index > -1) {
                currentUrl.searchParams.delete(name);
                delete values[index];
                values.forEach((v) => currentUrl.searchParams.append(name, v));
            }
            else {
                currentUrl.searchParams.append(name, value);
            }
        }
        else {
            currentUrl.searchParams.delete(name);
            if (value) {
                currentUrl.searchParams.append(name, value);
            }
        }
        let query = currentUrl.searchParams.toString();
        query = (query) ? `?${query}` : currentUrl.pathname;
        history.pushState({}, document.title, query);
    }
    static getSearchParam(name) {
        const currentUrl = new URL(window.location.href);
        return currentUrl.searchParams.get(name);
    }
    static getSearchParams(name) {
        const currentUrl = new URL(window.location.href);
        return currentUrl.searchParams.getAll(name);
    }
}

class Optional {
    constructor(value) {
        this.value = value;
        if (typeof this.value === 'object' &&
            this.value !== null) {
            return new Proxy(this.value, {
                get(target, name, receiver) {
                    return Reflect.get(target, name, receiver);
                },
            });
        }
    }
}
function optional(value = null, callback = null) {
    if (callback === null) {
        return new Optional(value);
    }
    else if (value !== null) {
        return callback(value);
    }
}

class Events {
    static emit(name, data = {}) {
        const event = new CustomEvent(name, {
            'detail': data,
        });
        document.dispatchEvent(event);
    }
}
/**
 * Called when the grouped search bar is submitted
 */
Events.onSubmitGroupedSearch = 'onSubmitGroupedSearch';
/**
 * Called when the grouped search bar starts searching
 */
Events.onGroupedSearch = 'onGroupedSearch';
/**
 * Called before the grouped search bar starts searching
 */
Events.onBeforeGroupedSearch = 'onBeforeGroupedSearch';
/**
 * Called after the grouped search bar finishes searching
 */
Events.onAfterGroupedSearch = 'onAfterGroupedSearch';
/**
 * When the arrow up or down is pressed
 */
Events.onArrowMovementGroupedSearch = 'onArrowMovementGroupedSearch';
Events.groupedSearchOpened = 'groupedSearchOpened';
Events.groupedSearchClosed = 'groupedSearchClosed';
/**
 * Called when the autocomplete bar is submitted
 */
Events.onSubmitSearch = 'onSubmitSearch';
/**
 * Called when the autocomplete bar starts searching
 */
Events.onSearch = 'onSearch';
/**
 * Called before the autocomplete bar starts searching
 */
Events.onBeforeSearch = 'onBeforeSearch';
/**
 * Called after the autocomplete bar finishes searching
 */
Events.onAfterSearch = 'onAfterSearch';
/**
 * When the arrow up or down is pressed
 */
Events.onArrowMovementSearch = 'onArrowMovementSearch';
Events.onForceResultBlur = 'onForceResultBlur';
Events.searchOpened = 'searchOpened';
Events.searchClosed = 'searchClosed';
/**
 * When the result should be updated
 */
Events.onResultRequest = 'onResultRequest';
/**
 * Before the results are updated
 */
Events.onBeforeResultRequest = 'onBeforeResultRequest';
/**
 * After the results are updated
 */
Events.onAfterResultRequest = 'onAfterResultRequest';
/**
 * When a page gets changed
 */
Events.onPageChange = 'onPageChange';
Events.onClickResult = 'onClickResult';
/**
 * When any of the aggregations are updated
 */
Events.onAggsUpdate = 'onAggsUpdate';
Events.onAggregationValueChange = 'onAggregationValueChange';
Events.autocompleteBarFinished = 'autocompleteBarFinished';
Events.groupedSearchBarFinished = 'groupedSearchBarFinished';
Events.resultFinished = 'resultFinished';
Events.aggregationFinished = 'aggregationFinished';
Events.initializeSlider = 'initializeSlider';
Events.initializeSwitch = 'initializeSwitch';

class Aggregation {
    constructor(options = {}) {
        /**
         * @type {string} A custom template for the aggregation, if not set a default will be used
         */
        this.template = null;
        /**
         * The values that are set for the aggregation
         */
        this.values = {};
        /**
         * The value sent to the search
         */
        this.value = {};
        /**
         * Is the item collapsible or not
         */
        this.collapsible = false;
        /**
         * Is the item default collapsed
         */
        this.defaultCollapsed = false;
        this.hasActiveAggregation = true;
        this.useSkeleton = null;
        this.setTitle(options.title || '');
        this.setClassTitle(this.getTitle() || '');
        this.setTemplate(options.template || '');
        this.setAttribute(options.attribute || this.getTitle());
        this.setCollapsible(options.collapsible || this.getCollapsible());
        this.setDefaultCollapsed(options.default_collapsed || this.getDefaultCollapsed());
        this.setUseSkeleton((typeof optional(options).use_skeleton !== 'undefined') ?
            optional(options).use_skeleton : this.getUseSkeleton());
        this.setSkeletonTemplate(optional(options).skeleton_template || this.getSkeletonTemplate());
    }
    getUseSkeleton() {
        if (this.useSkeleton === null && this.parent) {
            return this.parent.getUseSkeleton();
        }
        return this.useSkeleton;
    }
    setUseSkeleton(useSkeleton) {
        this.useSkeleton = useSkeleton;
        return this;
    }
    setSkeletonTemplate(template) {
        this.skeletonTemplate = template;
        return this;
    }
    getSkeletonTemplate() {
        return this.skeletonTemplate;
    }
    renderSkeleton() {
        const rendered = Mustache.render(this.getSkeletonTemplate(), {
            class_title: this.getClassTitle(),
        });
        return rendered;
    }
    setClassTitle(classTitle) {
        this.classTitle = classTitle.replace(/ /g, '-');
        return this;
    }
    getClassTitle() {
        return this.classTitle;
    }
    setAttribute(attribute) {
        this.attribute = attribute;
        if (!this.value.field) {
            this.value = {
                field: this.attribute,
                value: '',
                is_aggregation: true,
                exclude_from_search: true,
            };
        }
        return this;
    }
    getAttribute() {
        return this.attribute;
    }
    setCollapsible(collapsible) {
        this.collapsible = collapsible;
        return this;
    }
    getCollapsible() {
        return this.collapsible;
    }
    setDefaultCollapsed(defaultCollapsed) {
        this.defaultCollapsed = defaultCollapsed;
        return this;
    }
    getDefaultCollapsed() {
        return this.defaultCollapsed;
    }
    setTitle(title) {
        this.title = title;
        this.setClassTitle(this.title);
        return this;
    }
    getTitle() {
        return this.title;
    }
    setTemplate(template) {
        this.template = template;
        return this;
    }
    getTemplate() {
        return this.template;
    }
    /**
     * This function will be used to render the HTML
     * This is done by using Mustache-JS
     * @return {string}
     */
    render() {
        return this.getTemplate();
    }
    /**
     * The after load Javascript, used for event listeners etc.
     */
    executeJS() {
    }
    reset() {
    }
}

class Widget {
    constructor(options = {}) {
        this.setEl(options.el || '');
    }
    setEl(el) {
        this.el = el;
        return this;
    }
    getEl() {
        return this.el;
    }
    getTemplate() {
        return this.template;
    }
    setTemplate(template) {
        this.template = template;
        return this;
    }
    setClient(client) {
        this.client = client;
        return this;
    }
    /**
     * Render the HTML and transform it into a HTML Node
     * @param {{}} options
     * @return {Node}
     */
    render(options = {}) {
        const template = this.getTemplate();
        return document.createRange().createContextualFragment(template);
    }
    executeJS() { }
    /**
     * Render and append the widgets into the right position
     * @param {{}} options
     */
    build(options = {}) {
        const elements = document.querySelectorAll(this.getEl());
        const domHtml = this.render(options);
        elements.forEach((element) => {
            element.innerHTML = '';
            element.appendChild(domHtml.cloneNode(true));
        });
        this.executeJS();
    }
}

class Switch extends Aggregation {
    constructor(options = {}) {
        super(options);
        this.discriminator = 'Switch';
        this.onValue = 'On';
        this.offValue = 'Off';
        this.setOnValue(options.on_value || this.getOnValue());
        this.setOffValue(options.off_value || this.getOffValue());
        this.setAttributeValue(options.attribute_value || this.getAttributeValue());
        this.value = {
            field: this.getAttribute(),
            value: '',
            is_aggregation: true,
            exclude_from_search: true,
        };
    }
    setAttributeValue(attributeValue) {
        this.attributeValue = attributeValue;
        return this;
    }
    getAttributeValue() {
        return this.attributeValue.toString();
    }
    setOnValue(onValue) {
        this.onValue = onValue;
        return this;
    }
    getOnValue() {
        return this.onValue;
    }
    setOffValue(offValue) {
        this.offValue = offValue;
        return this;
    }
    getOffValue() {
        return this.offValue;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template$7;
    }
    getSkeletonTemplate() {
        if (this.skeletonTemplate) {
            return this.skeletonTemplate;
        }
        return skeletonTemplate$3;
    }
    renderSkeleton() {
        const rendered = Mustache.render(this.getSkeletonTemplate(), {
            class_title: this.getClassTitle(),
        });
        return rendered;
    }
    render() {
        const template = this.getTemplate();
        return Mustache.render(template, {
            title: this.getTitle(),
            class_title: this.getClassTitle(),
            name: this.getClassTitle(),
            on_value: this.getOnValue(),
            off_value: this.getOffValue(),
            collapsible: (this.getCollapsible()) ? 'needletail-collapsible' : '',
            collapsed: (this.getCollapsible() && this.getDefaultCollapsed()) ? 'needletail-collapsed' : '',
        });
    }
    /**
     * Add listeners, set the default value
     */
    executeJS() {
        if (this.getUseSkeleton()) {
            document.addEventListener(Events.onAfterResultRequest, (e) => {
                const textElement = this.render();
                const node = document.createRange().createContextualFragment(textElement);
                document.querySelectorAll(`.needletail-aggregation-switch-${this.getClassTitle()}`).forEach((element) => {
                    element.replaceWith(node);
                    this.initialize();
                    Events.emit(Events.initializeSwitch);
                });
            });
        }
        else {
            this.initialize();
            document.addEventListener('DOMContentLoaded', () => {
                Events.emit(Events.initializeSwitch);
            });
        }
    }
    initialize() {
        const title = this.getTitle();
        const prevVal = URIHelper.getSearchParam(title);
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation-switch-input.needletail-aggregation-switch-input-${this.getClassTitle()}`)
            .forEach((element) => {
            // Set the default value
            element.checked = (URIHelper.getSearchParam(title) === this.getAttributeValue());
            element.addEventListener('change', () => {
                this.handle(element);
            });
            if (element.checked) {
                this.hasActiveAggregation = true;
                Events.emit(Events.onAggregationValueChange, {
                    'initial': true,
                    'name': this.getAttribute(),
                    'hasActive': this.hasActiveAggregation,
                });
            }
        });
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-switch.needletail-aggregation-switch-${this.getClassTitle()}`)
            .forEach((element) => {
            if (this.getCollapsible()) {
                element.querySelector('.needletail-aggregation-switch-title')
                    .addEventListener('click', (e) => {
                    if (element.classList.contains('needletail-collapsed')) {
                        element.classList.remove('needletail-collapsed');
                    }
                    else {
                        element.classList.add('needletail-collapsed');
                    }
                });
            }
        });
        this.values[prevVal] = prevVal;
        this.value = {
            field: this.getAttribute(),
            value: prevVal,
            is_aggregation: true,
        };
    }
    handle(element, skipHistory = false) {
        const attributeValue = this.getAttributeValue();
        if (!skipHistory) {
            URIHelper.addToHistory(this.getTitle(), attributeValue, true);
        }
        if (this.values[attributeValue]) {
            delete this.values[attributeValue];
        }
        else {
            this.values[attributeValue] = attributeValue;
        }
        this.value = {
            field: this.getAttribute(),
            value: (this.values[attributeValue]) ? attributeValue : '',
            is_aggregation: true,
        };
        this.hasActiveAggregation = true;
        if (!this.values[attributeValue]) {
            this.value = {
                field: this.getAttribute(),
                value: '',
                is_aggregation: true,
                exclude_from_search: true,
            };
            this.hasActiveAggregation = false;
        }
        Events.emit(Events.onBeforeResultRequest, {});
        Events.emit(Events.onAggregationValueChange, {
            'initial': false,
            'name': this.getAttribute(),
            'hasActive': this.hasActiveAggregation,
            'value': this.value.value,
        });
    }
    reset() {
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation-switch-input.needletail-aggregation-switch-input-${this.getClassTitle()}`)
            .forEach((element) => {
            if (element.checked) {
                element.checked = false;
                this.handle(element);
            }
        });
    }
}

var template$6 = "<div class=\"needletail-aggregation needletail-aggregation-checkbox needletail-aggregation-checkbox-{{ class_title }} {{ collapsible }} {{ collapsed }}\">\n    <div class=\"needletail-aggregation-checkbox-title\">\n        {{ title }}\n    </div>\n    <div class=\"needletail-collapsible-container\">\n        {{#options}}\n            <label class=\"needletail-aggregation-checkbox-option {{#show_more_options}}needletail-hidden{{/show_more_options}}\">\n                <input type=\"checkbox\" name=\"{{ name }}\" value=\"{{ value }}\" class=\"needletail-aggregation-checkbox-option-input needletail-aggregation-checkbox-option-input-{{ name }}\">\n                <span class=\"needletail-aggregation-checkbox-option-checkmark\"></span>\n                <span class=\"needletail-aggregation-checkbox-option-label\">{{ value }}</span>\n                <span class=\"needletail-aggregation-checkbox-option-count\">{{ count }}</span>\n            </label>\n        {{/options}}\n        {{#show_more_options}}\n            <div class=\"needletail-show-more-options\">{{{ show_more_options_text }}}</div>\n            <div class=\"needletail-show-less-options needletail-hidden\">{{{ show_less_options_text }}}</div>\n        {{/show_more_options}}\n    </div>\n</div>\n";

var skeletonTemplate$2 = "<div class=\"needletail-aggregation needletail-aggregation-checkbox needletail-aggregation-checkbox-{{ class_title }} needletail-skeleton needletail-skeleton-spacing needletail-skeleton-spacing--l\">\n    <h3 class=\"needletail-skeleton-header needletail-skeleton-filter-heading\">\n        <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n    </h3>\n    <div>\n        {{#options}}\n            <div class=\"needletail-skeleton-filter-item\">\n                <span class=\"needletail-skeleton-box\" style=\"width:16px;\"></span>\n                <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n                <span class=\"needletail-skeleton-box needletail-skeleton-filter-count\" style=\"width:16px;\"></span>\n            </div>\n        {{/options}}\n    </div>\n\n    <div class=\"needletail-show-more-options needletail-hidden\"></div>\n    <div class=\"needletail-show-less-options needletail-hidden\"></div>\n</div>";

class Checkbox extends Aggregation {
    constructor(options = {}) {
        super(options);
        this.discriminator = 'Checkbox';
        this.hideOnEmpty = true;
        this.useShowMoreOptions = true;
        this.showMoreOptionsText = 'Show more options';
        this.showLessOptionsText = 'Show less options';
        this.showMoreOptionsLoad = 10;
        this.optionOrder = [];
        this.filterOptions = [];
        this.neverHideChecked = true;
        this.showSelectedZero = true;
        this.skeletonItemCount = 10;
        this.setHideOnEmpty(options.hide_on_empty || this.getHideOnEmpty());
        this.setUseShowMoreOptions((typeof optional(options.show_more_options).use !== 'undefined') ?
            options.show_more_options.use : this.getUseShowMoreOptions());
        this.setShowMoreOptionsText(optional(options.show_more_options).text ?
            options.show_more_options.text : this.getShowMoreOptionsText());
        this.setShowLessOptionsText(optional(options.show_more_options).less_text ?
            options.show_more_options.less_text : this.getShowLessOptionsText());
        this.setShowMoreOptionsLoad(optional(options.show_more_options).load ?
            options.show_more_options.load : this.getShowMoreOptionsLoad());
        this.setSkeletonItemCount(options.skeleton_item_count || this.getSkeletonItemCount());
        this.setOptionOrder(options.option_order || this.getOptionOrder());
        this.setFilterOptions(options.filter_options || this.getFilterOptions());
        this.setNeverHideChecked(optional(options.show_more_options).never_hide_checked ?
            options.show_more_options.never_hide_checked : this.getNeverHideChecked());
        this.setShowSelectedZero((typeof options.show_selected_zero !== 'undefined') ?
            options.show_selected_zero : this.getShowSelectedZero());
        this.value = {
            field: this.getAttribute(),
            value: '',
            is_aggregation: true,
            exclude_from_search: true,
        };
    }
    setSkeletonItemCount(skeletonItemCount) {
        this.skeletonItemCount = skeletonItemCount;
        return this;
    }
    getSkeletonItemCount() {
        return this.skeletonItemCount;
    }
    setOptionOrder(optionOrder) {
        this.optionOrder = optionOrder.map((o) => {
            return o.toLowerCase();
        });
        return this;
    }
    getOptionOrder() {
        return this.optionOrder;
    }
    setFilterOptions(filterOptions) {
        this.filterOptions = filterOptions.map((o) => {
            return o.toLowerCase();
        });
        return this;
    }
    getFilterOptions() {
        return this.filterOptions;
    }
    setShowSelectedZero(showSelectedZero) {
        this.showSelectedZero = showSelectedZero;
        return this;
    }
    getShowSelectedZero() {
        return this.showSelectedZero;
    }
    setNeverHideChecked(neverHideChecked) {
        this.neverHideChecked = neverHideChecked;
        return this;
    }
    getNeverHideChecked() {
        return this.neverHideChecked;
    }
    setUseShowMoreOptions(useShowMoreOptions) {
        this.useShowMoreOptions = useShowMoreOptions;
        return this;
    }
    getUseShowMoreOptions() {
        return this.useShowMoreOptions;
    }
    setShowMoreOptionsText(showMoreOptionsText) {
        this.showMoreOptionsText = showMoreOptionsText;
        return this;
    }
    getShowMoreOptionsText() {
        return this.showMoreOptionsText;
    }
    setShowLessOptionsText(showLessOptionsText) {
        this.showLessOptionsText = showLessOptionsText;
        return this;
    }
    getShowLessOptionsText() {
        return this.showLessOptionsText;
    }
    setShowMoreOptionsLoad(showMoreOptionsLoad) {
        this.showMoreOptionsLoad = showMoreOptionsLoad;
        return this;
    }
    getShowMoreOptionsLoad() {
        return this.showMoreOptionsLoad;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template$6;
    }
    setHideOnEmpty(hideOnEmpty) {
        this.hideOnEmpty = hideOnEmpty;
        return this;
    }
    getHideOnEmpty() {
        return this.hideOnEmpty;
    }
    getSkeletonTemplate() {
        if (this.skeletonTemplate) {
            return this.skeletonTemplate;
        }
        return skeletonTemplate$2;
    }
    renderSkeleton() {
        const rendered = Mustache.render(this.getSkeletonTemplate(), {
            class_title: this.getClassTitle(),
            options: new Array(this.getSkeletonItemCount()).fill(null),
        });
        return rendered;
    }
    render(options = []) {
        const template = this.getTemplate();
        if (this.getOptionOrder()) {
            options.sort((a, b) => {
                let indexA = this.getOptionOrder().indexOf(a.value.toLowerCase());
                let indexB = this.getOptionOrder().indexOf(b.value.toLowerCase());
                if (indexA === -1) {
                    indexA = 9999;
                }
                if (indexB === -1) {
                    indexB = 9999;
                }
                return indexA - indexB;
            });
        }
        if (this.getFilterOptions().length > 0) {
            options = options.filter((o) => {
                return this.getFilterOptions().indexOf(o.value.toLowerCase()) > -1;
            });
        }
        return Mustache.render(template, {
            title: this.getTitle(),
            class_title: this.getClassTitle(),
            options: options,
            collapsible: (this.getCollapsible()) ? 'needletail-collapsible' : '',
            collapsed: (this.getCollapsible() && this.getDefaultCollapsed()) ? 'needletail-collapsed' : '',
            show_more_options: this.getUseShowMoreOptions(),
            show_more_options_text: this.getShowMoreOptionsText(),
            show_less_options_text: this.getShowLessOptionsText(),
            checked_count: URIHelper.getSearchParams(this.getTitle()).length,
        });
    }
    /**
     * Add listeners, set the default value
     */
    executeJS() {
        const title = this.getTitle();
        document.addEventListener(Events.onAggsUpdate, (e) => {
            if (e.detail[this.getAttribute()]) {
                const options = [];
                e.detail[this.getAttribute()].forEach((val) => {
                    options.push(Object.assign({ name: this.getClassTitle() }, val));
                });
                // Whenever the aggregation gets updated it has to be rerendered
                const textElement = this.render(options);
                const node = document.createRange().createContextualFragment(textElement);
                let wasCollapsed = false;
                let wasShownMoreOptions = false;
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-checkbox.needletail-aggregation-checkbox-${this.getClassTitle()}`)
                    .forEach((element) => {
                    wasCollapsed = element.classList.contains('needletail-collapsed');
                    const showMoreOptionsElement = element.querySelector('.needletail-show-more-options');
                    const showLessOptionsElement = element.querySelector('.needletail-show-less-options');
                    if (this.getUseShowMoreOptions()) {
                        wasShownMoreOptions = !showMoreOptionsElement.classList.contains('needletail-hidden');
                        const bothHidden = (showMoreOptionsElement.classList.contains('needletail-hidden') &&
                            showLessOptionsElement.classList.contains('needletail-hidden'));
                        if (bothHidden) {
                            wasShownMoreOptions = true;
                        }
                    }
                    element.replaceWith(node.cloneNode(true));
                });
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-checkbox.needletail-aggregation-checkbox-${this.getClassTitle()}`)
                    .forEach((element) => {
                    if (this.getCollapsible()) {
                        element.querySelector('.needletail-aggregation-checkbox-title')
                            .addEventListener('click', (e) => {
                            if (element.classList.contains('needletail-collapsed')) {
                                element.classList.remove('needletail-collapsed');
                            }
                            else {
                                element.classList.add('needletail-collapsed');
                            }
                        });
                        if (wasCollapsed) {
                            element.classList.add('needletail-collapsed');
                        }
                    }
                    element.setAttribute('data-option-count', options.length.toString());
                    if (this.getHideOnEmpty()) {
                        if (options.length === 0) {
                            element.classList.add('needletail-empty');
                        }
                        else {
                            element.classList.remove('needletail-empty');
                        }
                    }
                    if (this.getUseShowMoreOptions()) {
                        const showMoreOptions = element
                            .querySelector('.needletail-show-more-options');
                        const showLessOptions = element
                            .querySelector('.needletail-show-less-options');
                        const checkboxOptions = element
                            .querySelectorAll('.needletail-aggregation-checkbox-option');
                        if (checkboxOptions.length <= this.getShowMoreOptionsLoad()) {
                            showMoreOptions.classList.add('needletail-hidden');
                        }
                        const max = (this.getShowMoreOptionsLoad() > checkboxOptions.length) ?
                            checkboxOptions.length : this.getShowMoreOptionsLoad();
                        for (let i = 0; i < max; i++) {
                            checkboxOptions.item(i).classList.remove('needletail-hidden');
                        }
                        showMoreOptions.addEventListener('click', (e) => {
                            showMoreOptions.classList.add('needletail-hidden');
                            showLessOptions.classList.remove('needletail-hidden');
                            for (let i = this.getShowMoreOptionsLoad(); i < checkboxOptions.length; i++) {
                                checkboxOptions.item(i).classList.remove('needletail-hidden');
                            }
                        });
                        showLessOptions.addEventListener('click', (e) => {
                            showLessOptions.classList.add('needletail-hidden');
                            showMoreOptions.classList.remove('needletail-hidden');
                            for (let i = this.getShowMoreOptionsLoad(); i < checkboxOptions.length; i++) {
                                const item = checkboxOptions.item(i);
                                const input = item
                                    .querySelector('.needletail-aggregation-checkbox-option-input');
                                if (!input.checked || !this.getNeverHideChecked()) {
                                    item.classList.add('needletail-hidden');
                                }
                            }
                        });
                        if (!wasShownMoreOptions &&
                            checkboxOptions.length > this.getShowMoreOptionsLoad()) {
                            showMoreOptions.click();
                        }
                    }
                });
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation-checkbox-option-input.needletail-aggregation-checkbox-option-input-${this.getClassTitle()}`)
                    .forEach((element) => {
                    element.addEventListener('change', () => {
                        this.handle(element);
                    });
                });
                // Set the default value for the aggregation
                const params = URIHelper.getSearchParams(title);
                if (params) {
                    params.forEach((value) => {
                        // eslint-disable-next-line max-len
                        const elements = document.querySelectorAll(`.needletail-aggregation-checkbox-option-input-${this.getClassTitle()}[value='${value}']`);
                        if (elements.length === 0) {
                            if (this.getShowSelectedZero()) {
                                const strippedValue = value.replace(/(<([^>]+)>)/gi, '');
                                if (strippedValue) {
                                    // eslint-disable-next-line max-len
                                    const lastItems = document.querySelectorAll(`.needletail-aggregation-checkbox-${this.getClassTitle()} .needletail-aggregation-checkbox-option`);
                                    const lastItem = lastItems[lastItems.length - 1];
                                    const newItem = lastItem.cloneNode(true);
                                    lastItem.after(newItem);
                                    // eslint-disable-next-line max-len
                                    const newLastItems = document.querySelectorAll(`.needletail-aggregation-checkbox-${this.getClassTitle()} .needletail-aggregation-checkbox-option`);
                                    const newLastItem = newLastItems[newLastItems.length - 1];
                                    const text = newLastItem.querySelector('.needletail-aggregation-checkbox-option-label');
                                    const count = newLastItem.querySelector('.needletail-aggregation-checkbox-option-count');
                                    // eslint-disable-next-line max-len
                                    const input = newLastItem.querySelector('.needletail-aggregation-checkbox-option-input');
                                    if (text) {
                                        text.innerHTML = strippedValue;
                                    }
                                    if (count) {
                                        count.innerHTML = '0';
                                    }
                                    if (input) {
                                        input.setAttribute('value', strippedValue);
                                        input.checked = true;
                                        this.values[strippedValue] = strippedValue;
                                        input.addEventListener('change', () => {
                                            this.handle(input);
                                        });
                                    }
                                }
                            }
                        }
                        else {
                            elements.forEach((element) => {
                                element.checked = true;
                                element.parentElement.classList.remove('needletail-hidden');
                            });
                        }
                    });
                }
            }
            else {
                if (this.getHideOnEmpty()) {
                    // eslint-disable-next-line max-len
                    document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-checkbox.needletail-aggregation-checkbox-${this.getClassTitle()}`)
                        .forEach((element) => {
                        element.classList.add('needletail-empty');
                    });
                }
            }
        });
        const params = URIHelper.getSearchParams(title);
        // On load set the values for the aggregation search
        if (params) {
            params.forEach((value) => {
                if (value) {
                    this.values[value] = value;
                }
            });
            this.value = {
                field: this.getAttribute(),
                value: Object.keys(this.values),
                is_aggregation: true,
            };
            this.hasActiveAggregation = true;
            if (Object.keys(this.values).length === 0) {
                this.hasActiveAggregation = false;
                this.value = {
                    field: this.getAttribute(),
                    value: '',
                    is_aggregation: true,
                    exclude_from_search: true,
                };
            }
            Events.emit(Events.onAggregationValueChange, {
                'initial': true,
                'name': this.getAttribute(),
                'hasActive': this.hasActiveAggregation,
                'value': Object.keys(this.values),
            });
        }
    }
    handle(element, skipHistory = false) {
        if (!skipHistory) {
            URIHelper.addToHistory(this.getTitle(), element.value, true);
        }
        if (this.values[element.value]) {
            delete this.values[element.value];
        }
        else {
            this.values[element.value] = element.value;
        }
        this.value = {
            field: this.getAttribute(),
            value: Object.keys(this.values),
            is_aggregation: true,
        };
        this.hasActiveAggregation = true;
        if (Object.keys(this.values).length === 0) {
            this.value = {
                field: this.getAttribute(),
                value: '',
                is_aggregation: true,
                exclude_from_search: true,
            };
            this.hasActiveAggregation = false;
        }
        Events.emit(Events.onBeforeResultRequest, {});
        Events.emit(Events.onAggregationValueChange, {
            'initial': false,
            'name': this.getAttribute(),
            'hasActive': this.hasActiveAggregation,
            'value': this.value.value,
            'lastValue': element.value,
        });
    }
    reset() {
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation-checkbox-option-input.needletail-aggregation-checkbox-option-input-${this.getClassTitle()}`)
            .forEach((element) => {
            if (element.checked) {
                element.checked = false;
                this.handle(element);
            }
        });
    }
}

var template$5 = "<div class=\"needletail-aggregation needletail-aggregation-radio needletail-aggregation-radio-{{ class_title }} {{ collapsible }} {{ collapsed }}\">\n    <div class=\"needletail-aggregation-radio-title\">\n        {{ title }}\n    </div>\n    <div class=\"needletail-collapsible-container\">\n        {{#options}}\n            <label class=\"needletail-aggregation-radio-option {{#show_more_options}}needletail-hidden{{/show_more_options}}\">\n                <input type=\"radio\" name=\"{{ name }}\" value=\"{{ value }}\" class=\"needletail-aggregation-radio-option-input needletail-aggregation-radio-option-input-{{ name }}\">\n                <span class=\"needletail-aggregation-radio-option-checkmark\"></span>\n                <span class=\"needletail-aggregation-radio-option-label\">{{ value }}</span>\n                <span class=\"needletail-aggregation-radio-option-count\">{{ count }}</span>\n            </label>\n        {{/options}}\n        {{#show_more_options}}\n            <div class=\"needletail-show-more-options\">{{{ show_more_options_text }}}</div>\n            <div class=\"needletail-show-less-options needletail-hidden\">{{{ show_less_options_text }}}</div>\n        {{/show_more_options}}\n    </div>\n</div>\n";

var skeletonTemplate$1 = "<div class=\"needletail-aggregation needletail-aggregation-radio needletail-aggregation-radio-{{ class_title }} needletail-skeleton needletail-skeleton-spacing needletail-skeleton-spacing--l\">\n    <h3 class=\"needletail-skeleton-header needletail-skeleton-filter-heading\">\n        <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n    </h3>\n    <div>\n        {{#options}}\n            <div class=\"needletail-skeleton-filter-item\">\n                <span class=\"needletail-skeleton-box\" style=\"width:16px;\"></span>\n                <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n                <span class=\"needletail-skeleton-box needletail-skeleton-filter-count\" style=\"width:16px;\"></span>\n            </div>\n        {{/options}}\n    </div>\n\n    <div class=\"needletail-show-more-options needletail-hidden\"></div>\n    <div class=\"needletail-show-less-options needletail-hidden\"></div>\n</div>";

class Radio extends Aggregation {
    constructor(options = {}) {
        super(options);
        this.discriminator = 'Radio';
        this.hideOnEmpty = true;
        this.useShowMoreOptions = true;
        this.showMoreOptionsText = 'Show more options';
        this.showLessOptionsText = 'Show less options';
        this.showMoreOptionsLoad = 10;
        this.optionOrder = [];
        this.filterOptions = [];
        this.skeletonItemCount = 10;
        this.setHideOnEmpty(options.hide_on_empty || this.getHideOnEmpty());
        this.setUseShowMoreOptions((typeof optional(options.show_more_options).use !== 'undefined') ?
            options.show_more_options.use : this.getUseShowMoreOptions());
        this.setShowMoreOptionsText(optional(options.show_more_options).text ?
            options.show_more_options.text : this.getShowMoreOptionsText());
        this.setShowLessOptionsText(optional(options.show_more_options).less_text ?
            options.show_more_options.less_text : this.getShowLessOptionsText());
        this.setShowMoreOptionsLoad(optional(options.show_more_options).load ?
            options.show_more_options.load : this.getShowMoreOptionsLoad());
        this.setSkeletonItemCount(options.skeleton_item_count || this.getSkeletonItemCount());
        this.setOptionOrder(options.option_order || this.getOptionOrder());
        this.setFilterOptions(options.filter_options || this.getFilterOptions());
        this.value = {
            field: this.getAttribute(),
            value: '',
            is_aggregation: true,
            exclude_from_search: true,
        };
    }
    setSkeletonItemCount(skeletonItemCount) {
        this.skeletonItemCount = skeletonItemCount;
        return this;
    }
    getSkeletonItemCount() {
        return this.skeletonItemCount;
    }
    setOptionOrder(optionOrder) {
        this.optionOrder = optionOrder.map((o) => {
            return o.toLowerCase();
        });
        return this;
    }
    getOptionOrder() {
        return this.optionOrder;
    }
    setFilterOptions(filterOptions) {
        this.filterOptions = filterOptions.map((o) => {
            return o.toLowerCase();
        });
        return this;
    }
    getFilterOptions() {
        return this.filterOptions;
    }
    setUseShowMoreOptions(useShowMoreOptions) {
        this.useShowMoreOptions = useShowMoreOptions;
        return this;
    }
    getUseShowMoreOptions() {
        return this.useShowMoreOptions;
    }
    setShowMoreOptionsText(showMoreOptionsText) {
        this.showMoreOptionsText = showMoreOptionsText;
        return this;
    }
    getShowMoreOptionsText() {
        return this.showMoreOptionsText;
    }
    setShowLessOptionsText(showLessOptionsText) {
        this.showLessOptionsText = showLessOptionsText;
        return this;
    }
    getShowLessOptionsText() {
        return this.showLessOptionsText;
    }
    setShowMoreOptionsLoad(showMoreOptionsLoad) {
        this.showMoreOptionsLoad = showMoreOptionsLoad;
        return this;
    }
    getShowMoreOptionsLoad() {
        return this.showMoreOptionsLoad;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template$5;
    }
    setHideOnEmpty(hideOnEmpty) {
        this.hideOnEmpty = hideOnEmpty;
        return this;
    }
    getHideOnEmpty() {
        return this.hideOnEmpty;
    }
    getSkeletonTemplate() {
        if (this.skeletonTemplate) {
            return this.skeletonTemplate;
        }
        return skeletonTemplate$1;
    }
    renderSkeleton() {
        const rendered = Mustache.render(this.getSkeletonTemplate(), {
            class_title: this.getClassTitle(),
            options: new Array(this.getSkeletonItemCount()).fill(null),
        });
        return rendered;
    }
    render(options = []) {
        const template = this.getTemplate();
        if (this.getOptionOrder()) {
            options.sort((a, b) => {
                let indexA = this.getOptionOrder().indexOf(a.value.toLowerCase());
                let indexB = this.getOptionOrder().indexOf(b.value.toLowerCase());
                if (indexA === -1) {
                    indexA = 9999;
                }
                if (indexB === -1) {
                    indexB = 9999;
                }
                return indexA - indexB;
            });
        }
        if (this.getFilterOptions().length > 0) {
            options = options.filter((o) => {
                return this.getFilterOptions().indexOf(o.value.toLowerCase()) > -1;
            });
        }
        return Mustache.render(template, {
            title: this.getTitle(),
            class_title: this.getClassTitle(),
            options: options,
            collapsible: (this.getCollapsible()) ? 'needletail-collapsible' : '',
            collapsed: (this.getCollapsible() && this.getDefaultCollapsed()) ? 'needletail-collapsed' : '',
            show_more_options: this.getUseShowMoreOptions(),
            show_more_options_text: this.getShowMoreOptionsText(),
            show_less_options_text: this.getShowLessOptionsText(),
        });
    }
    /**
     * Add listeners, set the default value
     */
    executeJS() {
        const title = this.getTitle();
        const prevVal = URIHelper.getSearchParam(title);
        document.addEventListener(Events.onAggsUpdate, (e) => {
            if (e.detail[this.getAttribute()]) {
                const options = [];
                e.detail[this.getAttribute()].forEach((val) => {
                    options.push(Object.assign({ name: this.getClassTitle() }, val));
                });
                // Re-render the options
                const textElement = this.render(options);
                const node = document.createRange().createContextualFragment(textElement);
                let wasCollapsed = false;
                let wasShownMoreOptions = false;
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-radio.needletail-aggregation-radio-${this.getClassTitle()}`)
                    .forEach((element) => {
                    wasCollapsed = element.classList.contains('needletail-collapsed');
                    const showMoreOptionsElement = element.querySelector('.needletail-show-more-options');
                    const showLessOptionsElement = element.querySelector('.needletail-show-less-options');
                    if (this.getUseShowMoreOptions()) {
                        wasShownMoreOptions = !showMoreOptionsElement.classList.contains('needletail-hidden');
                        const bothHidden = (showMoreOptionsElement.classList.contains('needletail-hidden') &&
                            showLessOptionsElement.classList.contains('needletail-hidden'));
                        if (bothHidden) {
                            wasShownMoreOptions = true;
                        }
                    }
                    element.replaceWith(node.cloneNode(true));
                });
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-radio.needletail-aggregation-radio-${this.getClassTitle()}`)
                    .forEach((element) => {
                    if (this.getCollapsible()) {
                        element.querySelector('.needletail-aggregation-radio-title')
                            .addEventListener('click', (e) => {
                            if (element.classList.contains('needletail-collapsed')) {
                                element.classList.remove('needletail-collapsed');
                            }
                            else {
                                element.classList.add('needletail-collapsed');
                            }
                        });
                        if (wasCollapsed) {
                            element.classList.add('needletail-collapsed');
                        }
                    }
                    element.setAttribute('data-option-count', options.length.toString());
                    if (this.getHideOnEmpty()) {
                        if (options.length === 0) {
                            element.classList.add('needletail-empty');
                        }
                        else {
                            element.classList.remove('needletail-empty');
                        }
                    }
                    if (this.getUseShowMoreOptions()) {
                        const showMoreOptions = element.querySelector('.needletail-show-more-options');
                        const showLessOptions = element.querySelector('.needletail-show-less-options');
                        const radioOptions = element.querySelectorAll('.needletail-aggregation-radio-option');
                        if (radioOptions.length <= this.getShowMoreOptionsLoad()) {
                            showMoreOptions.classList.add('needletail-hidden');
                        }
                        const max = (this.getShowMoreOptionsLoad() > radioOptions.length) ?
                            radioOptions.length : this.getShowMoreOptionsLoad();
                        for (let i = 0; i < max; i++) {
                            radioOptions.item(i).classList.remove('needletail-hidden');
                        }
                        showMoreOptions.addEventListener('click', (e) => {
                            showMoreOptions.classList.add('needletail-hidden');
                            showLessOptions.classList.remove('needletail-hidden');
                            for (let i = this.getShowMoreOptionsLoad(); i < radioOptions.length; i++) {
                                radioOptions.item(i).classList.remove('needletail-hidden');
                            }
                        });
                        showLessOptions.addEventListener('click', (e) => {
                            showLessOptions.classList.add('needletail-hidden');
                            showMoreOptions.classList.remove('needletail-hidden');
                            for (let i = this.getShowMoreOptionsLoad(); i < radioOptions.length; i++) {
                                radioOptions.item(i).classList.add('needletail-hidden');
                            }
                        });
                        if (!wasShownMoreOptions &&
                            radioOptions.length > this.getShowMoreOptionsLoad()) {
                            showMoreOptions.click();
                        }
                    }
                });
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation-radio-option-input.needletail-aggregation-radio-option-input-${this.getClassTitle()}`)
                    .forEach((element) => {
                    element.addEventListener('change', () => {
                        this.handle(element);
                    });
                });
                // eslint-disable-next-line max-len
                document.querySelectorAll(`.needletail-aggregation-radio-option-input.needletail-aggregation-radio-option-input-${this.getClassTitle()}`)
                    .forEach((element) => {
                    // If the value is in the parameters check it
                    element.checked = (URIHelper.getSearchParam(title) === element.value);
                    element.addEventListener('change', () => {
                        this.handle(element);
                    });
                });
            }
        });
        this.value = {
            field: this.getAttribute(),
            value: prevVal,
            is_aggregation: true,
        };
    }
    handle(element, skipHistory = false, removeFromHistory = false) {
        if (!skipHistory) {
            URIHelper.addToHistory(this.getTitle(), element.value, removeFromHistory);
        }
        if (removeFromHistory) {
            element.value = '';
        }
        this.value = {
            field: this.getAttribute(),
            value: element.value,
            is_aggregation: true,
        };
        this.hasActiveAggregation = true;
        if (!element.value) {
            this.value = {
                field: this.getAttribute(),
                value: '',
                is_aggregation: true,
                exclude_from_search: true,
            };
            this.hasActiveAggregation = false;
        }
        Events.emit(Events.onBeforeResultRequest, {});
        Events.emit(Events.onAggregationValueChange, {
            'initial': false,
            'name': this.getAttribute(),
            'hasActive': this.hasActiveAggregation,
            'value': this.value.value,
            'lastValue': element.value,
        });
    }
    reset() {
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation-radio-option-input.needletail-aggregation-radio-option-input-${this.getClassTitle()}`)
            .forEach((element) => {
            if (element.checked) {
                element.checked = false;
                this.handle(element, false, true);
            }
        });
    }
}

var template$4 = "<div class=\"needletail-aggregation needletail-aggregation-slider needletail-aggregation-slider-{{ class_title }} {{ collapsible }} {{ collapsed }}\">\n    <div class=\"needletail-aggregation-slider-title\">\n        {{ title }}\n    </div>\n    <div class=\"needletail-collapsible-container\">\n        <div class=\"needletail-aggregation-slider-container\">\n            <input type=\"range\" name=\"{{ name }}\" min=\"{{ min }}\" max=\"{{ max }}\" value=\"{{ value }}\" class=\"needletail-aggregation-slider-input needletail-aggregation-slider-input-{{ name }}\">\n        </div>\n    </div>\n</div>";

var templateRange = "<div class=\"needletail-aggregation needletail-aggregation-slider needletail-aggregation-slider-{{ class_title }} {{ collapsible }} {{ collapsed }}\">\n    <div class=\"needletail-aggregation-slider-title\">\n        {{ title }}\n    </div>\n    <div class=\"needletail-collapsible-container\">\n        <div class=\"needletail-aggregation-slider-container__range\">\n            {{#inputs_top}}\n            <div class=\"needletail-aggregation-slider-inputs top\">\n                <input type=\"number\" class=\"needletail-aggregation-slider-input-min {{ display_only }}\">\n                <input type=\"number\" class=\"needletail-aggregation-slider-input-max {{ display_only }}\">\n            </div>\n            {{/inputs_top}}\n            <div class=\"needletail-aggregation-slider-range-container\">\n                <div class=\"needletail-aggregation-slider-range\">\n                    <div class=\"needletail-aggregation-slider-range-left\"></div>\n                    <div class=\"needletail-aggregation-slider-range-divider\"></div>\n                    <div class=\"needletail-aggregation-slider-range-right\"></div>\n                </div>\n            </div>\n            {{#inputs_bottom}}\n                <div class=\"needletail-aggregation-slider-inputs bottom\">\n                    <input type=\"number\" class=\"needletail-aggregation-slider-input-min {{ display_only }}\">\n                    <input type=\"number\" class=\"needletail-aggregation-slider-input-max {{ display_only }}\">\n                </div>\n            {{/inputs_bottom}}\n        </div>\n    </div>\n</div>";

var skeletonTemplate = "<div class=\"needletail-aggregation needletail-aggregation-slider needletail-aggregation-slider-{{ class_title }}\">\n    <div class=\"needletail-skeleton needletail-skeleton-spacing needletail-skeleton-spacing--l\">\n        <h3 class=\"needletail-skeleton-header\">\n            <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n        </h3>\n        <span class=\"needletail-skeleton-box\" style=\"width:100%;\"></span>\n    </div>\n</div>\n";

class Slider extends Aggregation {
    constructor(options = {}) {
        super(options);
        this.discriminator = 'Range';
        this.range = false;
        this.type = 'to';
        this.allowedTypes = ['to', 'from', 'from:to'];
        this.inputs = 'top';
        this.allowedInputs = ['top', 'bottom'];
        this.displayOnly = false;
        this.setRange(options.min || 0, options.max || 10);
        this.setDefaultValue((typeof options.default_value === 'number') ? options.default_value : 5);
        this.setRangeSlider((typeof options.range !== 'undefined') ?
            options.range : this.getRangeSlider());
        this.setDefaultRangeMin(options.default_range_min || this.getMin());
        this.setDefaultRangeMax(options.default_range_max || this.getMax());
        this.setType(options.type || this.getType());
        this.setInputs(options.inputs || this.getInputs());
        this.setDisplayOnly((typeof options.display_only !== 'undefined') ?
            options.display_only : this.getDisplayOnly());
        let value = this.getDefaultValue().toString();
        if (this.getRangeSlider()) {
            this.setType('from:to');
            value = this.getDefaultRangeMin() + ':' + this.getDefaultRangeMax();
        }
        this.value = {
            field: this.getAttribute(),
            value: value,
            type: this.getType(),
            is_aggregation: true,
            exclude_from_search: true,
        };
        this.ranges = {};
        this.elements = {};
    }
    setDisplayOnly(displayOnly) {
        this.displayOnly = displayOnly;
        return this;
    }
    getDisplayOnly() {
        return this.displayOnly;
    }
    setType(type) {
        if (this.allowedTypes.indexOf(type) === -1) {
            type = 'to';
        }
        else if (type === 'from:to' && !this.getRangeSlider()) {
            type = 'to';
        }
        this.type = type;
        return this;
    }
    getType() {
        return this.type;
    }
    setInputs(inputs) {
        if (this.allowedInputs.indexOf(inputs) === -1) {
            inputs = 'top';
        }
        this.inputs = inputs;
        return this;
    }
    getInputs() {
        return this.inputs;
    }
    setRangeSlider(rangeSlider) {
        this.range = rangeSlider;
        return this;
    }
    getRangeSlider() {
        return this.range;
    }
    setMin(min) {
        this.min = min;
        return this;
    }
    getMin() {
        return this.min;
    }
    setMax(max) {
        this.max = max;
        return this;
    }
    getMax() {
        return this.max;
    }
    setDefaultValue(value) {
        this.defaultValue = value;
        return this;
    }
    getDefaultValue() {
        return this.defaultValue;
    }
    setDefaultRangeMin(min) {
        this.defaultRangeMin = min;
        return this;
    }
    getDefaultRangeMin() {
        return this.defaultRangeMin;
    }
    setDefaultRangeMax(max) {
        this.defaultRangeMax = max;
        return this;
    }
    getDefaultRangeMax() {
        return this.defaultRangeMax;
    }
    setRange(min, max) {
        this.setMin(min);
        this.setMax(max);
        return this;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        if (this.getRangeSlider()) {
            return templateRange;
        }
        return template$4;
    }
    getSkeletonTemplate() {
        if (this.skeletonTemplate) {
            return this.skeletonTemplate;
        }
        return skeletonTemplate;
    }
    renderSkeleton() {
        const rendered = Mustache.render(this.getSkeletonTemplate(), {
            class_title: this.getClassTitle(),
        });
        return rendered;
    }
    render() {
        const template = this.getTemplate();
        return Mustache.render(template, {
            title: this.getTitle(),
            class_title: this.getClassTitle(),
            name: this.getClassTitle(),
            min: this.getMin(),
            max: this.getMax(),
            value: this.getDefaultValue(),
            collapsible: (this.getCollapsible()) ? 'needletail-collapsible' : '',
            collapsed: (this.getCollapsible() && this.getDefaultCollapsed()) ? 'needletail-collapsed' : '',
            inputs_bottom: (this.getInputs() === 'bottom'),
            inputs_top: (this.getInputs() === 'top'),
            display_only: (this.getDisplayOnly()) ? 'display-only' : '',
        });
    }
    /**
     * Add listeners, set the default value
     */
    executeJS() {
        if (this.getUseSkeleton()) {
            document.addEventListener(Events.onAfterResultRequest, (e) => {
                const textElement = this.render();
                const node = document.createRange().createContextualFragment(textElement);
                document.querySelectorAll(`.needletail-aggregation-slider-${this.getClassTitle()}`).forEach((element) => {
                    element.replaceWith(node);
                    this.initialize();
                    Events.emit(Events.initializeSlider);
                });
            });
        }
        else {
            this.initialize();
            document.addEventListener('DOMContentLoaded', () => {
                Events.emit(Events.initializeSlider);
            });
        }
    }
    initialize() {
        const title = this.getTitle();
        const prevVal = URIHelper.getSearchParam(title);
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation-slider-input.needletail-aggregation-slider-input-${this.getClassTitle()}`)
            .forEach((element) => {
            element.value = prevVal || this.getDefaultValue().toString();
            document.addEventListener(Events.initializeSlider, () => {
                this.handle(element, true);
            });
            element.addEventListener('change', () => {
                this.handle(element);
            });
        });
        document.querySelectorAll('.needletail-aggregation-slider-container__range').forEach((element) => {
            document.addEventListener(Events.initializeSlider, () => {
                this.elements[this.getClassTitle()] = {
                    slider: element.querySelector('.needletail-aggregation-slider-range'),
                    inputMin: element.querySelector('.needletail-aggregation-slider-input-min'),
                    inputMax: element.querySelector('.needletail-aggregation-slider-input-max'),
                    leftSlider: element.querySelector('.needletail-aggregation-slider-range-left'),
                    rightSlider: element.querySelector('.needletail-aggregation-slider-range-right'),
                    divider: element.querySelector('.needletail-aggregation-slider-range-divider'),
                };
                const slider = this.elements[this.getClassTitle()].slider;
                const inputMin = this.elements[this.getClassTitle()].inputMin;
                const inputMax = this.elements[this.getClassTitle()].inputMax;
                const leftSlider = this.elements[this.getClassTitle()].leftSlider;
                const rightSlider = this.elements[this.getClassTitle()].rightSlider;
                const divider = this.elements[this.getClassTitle()].divider;
                inputMin.value = URIHelper.getSearchParam(title + '[min]') || this.getDefaultRangeMin().toString();
                inputMax.value = URIHelper.getSearchParam(title + '[max]') || this.getDefaultRangeMax().toString();
                [inputMin, inputMax].forEach((input) => {
                    input.min = this.getMin().toString();
                    input.max = this.getMax().toString();
                });
                this.ranges[this.getClassTitle()] = this.calculatePositions(slider, leftSlider, rightSlider);
                window.onresize = (e) => {
                    this.ranges[this.getClassTitle()] = this.calculatePositions(slider, leftSlider, rightSlider);
                    this.calculateDivider(divider, leftSlider, rightSlider);
                };
                inputMin.addEventListener('change', _debounce(() => {
                    if (parseInt(inputMin.value) < this.getMin()) {
                        inputMin.value = this.getMin().toString();
                    }
                    else if (parseInt(inputMin.value) > parseInt(inputMax.value)) {
                        inputMin.value = inputMax.value;
                    }
                    const percentage = ((100 / this.getMax()) * parseInt(inputMin.value));
                    leftSlider.style.left = percentage + '%';
                    inputMax.min = inputMin.value;
                    this.calculateDivider(divider, leftSlider, rightSlider);
                    this.handleRange(inputMin, inputMax);
                }, 200));
                inputMax.addEventListener('change', _debounce(() => {
                    if (parseInt(inputMax.value) > this.getMax()) {
                        inputMax.value = this.getMax().toString();
                    }
                    else if (parseInt(inputMax.value) < parseInt(inputMin.value)) {
                        inputMax.value = inputMin.value;
                    }
                    const percentage = ((100 / this.getMax()) * parseInt(inputMax.value));
                    rightSlider.style.left = `${percentage}%`;
                    inputMin.max = inputMax.value;
                    this.calculateDivider(divider, leftSlider, rightSlider);
                    this.handleRange(inputMin, inputMax);
                }, 200));
                leftSlider.addEventListener('mousedown', (e) => {
                    document.onmousemove = (e) => {
                        e.preventDefault();
                        this.moveLeft(e);
                    };
                    document.onmouseup = (e) => {
                        document.onmouseup = null;
                        document.onmousemove = null;
                    };
                });
                leftSlider.addEventListener('touchstart', (e) => {
                    document.ontouchmove = (e) => {
                        e.preventDefault();
                        this.moveLeft(e);
                    };
                    document.ontouchend = (e) => {
                        document.ontouchend = null;
                        document.ontouchmove = null;
                    };
                });
                rightSlider.addEventListener('mousedown', (e) => {
                    document.onmousemove = (e) => {
                        e.preventDefault();
                        this.moveRight(e);
                    };
                    document.onmouseup = (e) => {
                        document.onmouseup = null;
                        document.onmousemove = null;
                    };
                });
                rightSlider.addEventListener('touchstart', (e) => {
                    document.ontouchmove = (e) => {
                        e.preventDefault();
                        this.moveRight(e);
                    };
                    document.ontouchend = (e) => {
                        document.ontouchend = null;
                        document.ontouchmove = null;
                    };
                });
                if (URIHelper.getSearchParam(title + '[min]')) {
                    leftSlider.style.left = (100 / this.getMax()) * parseInt(inputMin.value) + '%';
                }
                if (URIHelper.getSearchParam(title + '[max]')) {
                    rightSlider.style.left = `${(100 / this.getMax()) * parseInt(inputMax.value)}%`;
                }
                this.calculateDivider(divider, leftSlider, rightSlider);
            });
        });
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation.needletail-aggregation-slider.needletail-aggregation-slider-${this.getClassTitle()}`)
            .forEach((element) => {
            if (this.getCollapsible()) {
                element.querySelector('.needletail-aggregation-slider-title')
                    .addEventListener('click', (e) => {
                    if (element.classList.contains('needletail-collapsed')) {
                        element.classList.remove('needletail-collapsed');
                    }
                    else {
                        element.classList.add('needletail-collapsed');
                    }
                });
            }
        });
    }
    handle(element, skipHistory = false) {
        if (!skipHistory) {
            URIHelper.addToHistory(this.getTitle(), element.value);
        }
        this.value = {
            field: this.getAttribute(),
            value: element.value,
            type: this.getType(),
            is_aggregation: true,
        };
        this.hasActiveAggregation = true;
        if (!element.value) {
            this.value = {
                field: this.getAttribute(),
                value: this.getDefaultValue(),
                type: this.getType(),
                is_aggregation: true,
                exclude_from_search: true,
            };
            this.hasActiveAggregation = false;
        }
        Events.emit(Events.onBeforeResultRequest, {});
        Events.emit(Events.onAggregationValueChange, {
            'initial': false,
            'name': this.getAttribute(),
            'hasActive': this.hasActiveAggregation,
            'value': this.value.value,
            'lastValue': element.value,
        });
    }
    handleRange(inputMin, inputMax, skipHistory = false) {
        if (!skipHistory) {
            URIHelper.addToHistory(this.getTitle() + '[min]', inputMin.value);
            URIHelper.addToHistory(this.getTitle() + '[max]', inputMax.value);
        }
        this.value = {
            field: this.getAttribute(),
            value: inputMin.value + ':' + inputMax.value,
            type: this.getType(),
            is_aggregation: true,
        };
        this.hasActiveAggregation = true;
        if (!inputMin.value && !inputMax.value) {
            this.value = {
                field: this.getAttribute(),
                value: this.getMin() + ':' + this.getMax(),
                type: this.getType(),
                is_aggregation: true,
                exclude_from_search: true,
            };
            this.hasActiveAggregation = false;
        }
        Events.emit(Events.onBeforeResultRequest, {});
        Events.emit(Events.onAggregationValueChange, {
            'name': this.getAttribute(),
            'hasActive': this.hasActiveAggregation,
            'value': this.value.value,
            'lastValue': inputMin.value + ':' + inputMax.value,
        });
    }
    reset() {
        // eslint-disable-next-line max-len
        document.querySelectorAll(`.needletail-aggregation-slider-input.needletail-aggregation-slider-input-${this.getClassTitle()}`)
            .forEach((element) => {
            element.value = this.getDefaultValue().toString();
            this.handle(element);
            URIHelper.addToHistory(this.getTitle(), element.value, true);
            Events.emit(Events.onAggregationValueChange, {
                'initial': true,
                'name': this.getAttribute(),
                'hasActive': false,
            });
        });
        document.querySelectorAll('.needletail-aggregation-slider-container__range')
            .forEach((element) => {
            const inputMin = this.elements[this.getClassTitle()].inputMin;
            const inputMax = this.elements[this.getClassTitle()].inputMax;
            const leftSlider = this.elements[this.getClassTitle()].leftSlider;
            const rightSlider = this.elements[this.getClassTitle()].rightSlider;
            const divider = this.elements[this.getClassTitle()].divider;
            inputMin.value = this.getDefaultRangeMin().toString();
            inputMax.value = this.getDefaultRangeMax().toString();
            leftSlider.style.left = (100 / this.getMax()) * parseInt(inputMin.value) + '%';
            rightSlider.style.left = (100 / this.getMax()) * parseInt(inputMax.value) + '%';
            this.handleRange(inputMin, inputMax);
            this.calculateDivider(divider, leftSlider, rightSlider);
            URIHelper.addToHistory(this.getTitle() + '[min]', inputMin.value, true);
            URIHelper.addToHistory(this.getTitle() + '[max]', inputMax.value, true);
            Events.emit(Events.onAggregationValueChange, {
                'initial': true,
                'name': this.getAttribute(),
                'hasActive': false,
            });
            this.ranges[this.getClassTitle()].leftPosition = this.ranges[this.getClassTitle()].startLeft;
            this.ranges[this.getClassTitle()].rightPosition = this.ranges[this.getClassTitle()].startRight;
        });
    }
    calculatePositions(slider, leftSlider, rightSlider) {
        const startLeft = slider.getBoundingClientRect().x;
        const startRight = slider.getBoundingClientRect().x + slider.offsetWidth;
        const leftPosition = leftSlider.getBoundingClientRect().x;
        const rightPosition = rightSlider.getBoundingClientRect().x;
        const total = startRight - startLeft;
        return {
            startLeft: startLeft,
            startRight: startRight,
            leftPosition: leftPosition,
            rightPosition: rightPosition,
            total: total,
        };
    }
    calculateDivider(divider, leftSlider, rightSlider) {
        const width = rightSlider.offsetLeft - leftSlider.offsetLeft;
        divider.style.width = width + 'px';
        divider.style.left = `${leftSlider.style.left}`;
    }
    moveRight(e) {
        var _a;
        const clientX = (_a = e.clientX) !== null && _a !== void 0 ? _a : e.touches[0].clientX;
        const inputMax = this.elements[this.getClassTitle()].inputMax;
        const leftSlider = this.elements[this.getClassTitle()].leftSlider;
        const rightSlider = this.elements[this.getClassTitle()].rightSlider;
        const divider = this.elements[this.getClassTitle()].divider;
        if (!this.ranges[this.getClassTitle()]) {
            return;
        }
        let newLeft = (clientX - rightSlider.offsetWidth);
        if (newLeft < this.ranges[this.getClassTitle()].leftPosition) {
            newLeft = this.ranges[this.getClassTitle()].leftPosition;
        }
        else if (newLeft > this.ranges[this.getClassTitle()].startRight) {
            newLeft = this.ranges[this.getClassTitle()].startRight;
        }
        this.ranges[this.getClassTitle()].rightPosition = newLeft;
        const percentage = (100 / this.ranges[this.getClassTitle()].total) *
            (newLeft - this.ranges[this.getClassTitle()].startLeft);
        rightSlider.style.left = `${percentage}%`;
        inputMax.value = Math.round(((this.getMax() / 100) * percentage) + this.getMin()).toString();
        inputMax.dispatchEvent(new Event('change'));
        this.calculateDivider(divider, leftSlider, rightSlider);
    }
    moveLeft(e) {
        var _a;
        const clientX = (_a = e.clientX) !== null && _a !== void 0 ? _a : e.touches[0].clientX;
        const inputMin = this.elements[this.getClassTitle()].inputMin;
        const leftSlider = this.elements[this.getClassTitle()].leftSlider;
        const rightSlider = this.elements[this.getClassTitle()].rightSlider;
        const divider = this.elements[this.getClassTitle()].divider;
        if (!this.ranges[this.getClassTitle()]) {
            return;
        }
        let newLeft = (clientX - (leftSlider.offsetWidth / 2));
        if (newLeft > this.ranges[this.getClassTitle()].rightPosition) {
            newLeft = this.ranges[this.getClassTitle()].rightPosition;
        }
        else if (newLeft < this.ranges[this.getClassTitle()].startLeft) {
            newLeft = this.ranges[this.getClassTitle()].startLeft;
        }
        this.ranges[this.getClassTitle()].leftPosition = newLeft;
        const percentage = (100 / this.ranges[this.getClassTitle()].total) *
            (newLeft - this.ranges[this.getClassTitle()].startLeft);
        leftSlider.style.left = percentage + '%';
        inputMin.value = Math.round(((this.getMax() / 100) * percentage) + this.getMin()).toString();
        inputMin.dispatchEvent(new Event('change'));
        this.calculateDivider(divider, leftSlider, rightSlider);
    }
}

/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */

function __awaiter(thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

var template$3 = "<div class=\"needletail-autocomplete-bar needletail-autocomplete-bar-{{ name }}\">\n    <input type=\"text\" class=\"needletail-autocomplete-bar-input needletail-empty\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"{{ placeholder }}\">\n    {{{ results }}}\n</div>";

var resultTemplate$2 = "<div class=\"needletail-autocomplete-bar-results\">\n    {{#initial_input}}\n        <div class=\"needletail-autocomplete-bar-result needletail-initial-input\" data-attribute=\"{{ initial_input }}\">\n            {{ initial_input }}\n        </div>\n    {{/initial_input}}\n\n    {{#results}}\n        <div class=\"needletail-autocomplete-bar-result\" data-attribute=\"{{ raw.title }}\">\n            {{#highlight.title}}{{{ highlight.title }}}{{/highlight.title}}{{^highlight.title}}{{ title }}{{/highlight.title}}\n        </div>\n    {{/results}}\n    {{^results}}\n        <div class=\"needletail-autocomplete-bar-no-result\">\n            {{{ no_result_message }}}\n        </div>\n    {{/results}}\n</div>";

class AutocompleteBar extends Widget {
    constructor(options = {}) {
        super(options);
        /**
         * The discriminator used for sorting the widget
         */
        this.discriminator = 'AutocompleteBar';
        /**
         * Use debounce or not
         */
        this.debounce = true;
        /**
         * The time to wait for the debounce
         */
        this.debounceWait = 200;
        /**
         * The time to wait for the URL debounce
         */
        this.debounceUrlWait = 2000;
        /**
         * The name used in the URL for the field
         */
        this.query = 'autocompleteBar';
        /**
         * Save the value in the url
         */
        this.inUrl = true;
        /**
         * The placeholder of the input field
         */
        this.placeholder = 'Start typing to search';
        /**
         * The message to show if there are no results
         */
        this.noResultMessage = 'No results where found';
        /**
         * The result that has the active class on it
         */
        this.selectedResult = -1;
        /**
         * The value to send to the search
         */
        this.value = {};
        /**
         * The amount of results to show
         */
        this.size = 10;
        /**
         * The minimum amount of characters before executing.
         */
        this.minimumCharacters = 3;
        this.groupBy = '';
        this.sortBy = '';
        this.sortDirection = 'asc';
        /**
         * Show the results below the search bar
         */
        this.showResults = true;
        this.useInResults = true;
        this.searchOnContentLoaded = true;
        this.liveResults = false;
        this.initialInput = true;
        this.forceUseOfResult = false;
        this.skipForceResults = 0;
        this.fillInputOnClick = false;
        this.showBucket = false;
        this.sortMode = 'min';
        this.allowedDirections = ['asc', 'desc'];
        this.setUseDebounce((typeof optional(options.debounce).use !== 'undefined') ?
            options.debounce.use : this.getUseDebounce());
        this.setDebounceWait(optional(options.debounce).wait || this.getDebounceWait());
        this.setDebounceUrlWait(optional(options.debounce).url_wait || this.getDebounceUrlWait());
        this.setInUrl((typeof options.in_url !== 'undefined') ?
            options.in_url : this.getInUrl());
        this.setQuery(options.query || this.getQuery());
        this.setAttribute(optional(options.search).attribute || '');
        this.setAttributes(optional(options.search).attributes || '');
        this.setBuckets(optional(options.search).buckets || []);
        this.setPlaceholder(options.placeholder || this.getPlaceholder());
        this.setNoResultMessage(options.no_result_message || this.getNoResultMessage());
        this.setSize(optional(options.search).size || this.getSize());
        this.setGroupBy(optional(options.search).group_by || '');
        this.setSortBy(optional(options.search).sort_by || '');
        this.setSortDirection(optional(options.search).sort_direction || this.getSortDirection());
        this.setSortMode(optional(options.search).sort_mode || this.getSortMode());
        this.setMinimumCharacters((typeof options.minimum_characters !== 'undefined') ?
            options.minimum_characters : this.getMinimumCharacters());
        this.setShowResults((typeof options.show_results !== 'undefined') ?
            options.show_results : this.getShowResults());
        this.setForceUseOfResult((typeof options.force_use_of_result !== 'undefined') ?
            options.force_use_of_result : this.getForceUseOfResult());
        this.setUseInResults((typeof options.use_in_results !== 'undefined') ?
            options.use_in_results : this.getUseInResults());
        this.setSearchOnContentLoaded((typeof options.search_on_content_loaded !== 'undefined') ?
            options.search_on_content_loaded : this.getSearchOnContentLoaded());
        this.setLiveResults((typeof options.live_results !== 'undefined') ?
            options.live_results : this.getLiveResults());
        this.setInitialInput((typeof options.initial_input !== 'undefined') ?
            options.initial_input : this.getInitialInput());
        this.setFillInputOnClick((typeof options.fill_input_on_click !== 'undefined') ?
            options.fill_input_on_click : this.getFillInputOnClick());
        this.setShowBucket((typeof optional(options.search).show_bucket !== 'undefined') ?
            options.search.show_bucket : this.getShowBucket());
        this.setBucketMapping(optional(options.search).bucket_mapping || this.getBucketMapping());
        if (this.getInitialInput()) {
            this.skipForceResults = 1;
        }
    }
    setMinimumCharacters(minimumCharacters) {
        this.minimumCharacters = minimumCharacters;
        return this;
    }
    getMinimumCharacters() {
        return this.minimumCharacters;
    }
    setSize(size) {
        this.size = size;
        return this;
    }
    getSize() {
        return this.size;
    }
    setPlaceholder(placeholder) {
        this.placeholder = placeholder;
        return this;
    }
    getPlaceholder() {
        return this.placeholder;
    }
    setNoResultMessage(noResultMessage) {
        this.noResultMessage = noResultMessage;
        return this;
    }
    getNoResultMessage() {
        return this.noResultMessage;
    }
    setAttribute(attribute) {
        this.attribute = attribute;
        return this;
    }
    getAttribute() {
        return this.attribute;
    }
    setAttributes(attribute) {
        if (this.attribute === '') {
            this.attribute = attribute;
        }
        return this;
    }
    getAttributes() {
        return this.attribute;
    }
    setBuckets(buckets) {
        this.buckets = buckets;
        return this;
    }
    getBuckets() {
        return this.buckets;
    }
    setUseDebounce(use = true) {
        this.debounce = use;
        return this;
    }
    getUseDebounce() {
        return this.debounce;
    }
    setDebounceWait(wait) {
        this.debounceWait = wait;
        return this;
    }
    getDebounceWait() {
        return this.debounceWait;
    }
    setDebounceUrlWait(wait) {
        this.debounceUrlWait = wait;
        return this;
    }
    getDebounceUrlWait() {
        return this.debounceUrlWait;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template$3;
    }
    setResultTemplate(template) {
        this.resultTemplate = template;
        return this;
    }
    getResultTemplate() {
        if (this.resultTemplate) {
            return this.resultTemplate;
        }
        return resultTemplate$2;
    }
    setInUrl(inUrl) {
        this.inUrl = inUrl;
        return this;
    }
    getInUrl() {
        return this.inUrl;
    }
    setShowResults(showResults) {
        this.showResults = showResults;
        return this;
    }
    getShowResults() {
        return this.showResults;
    }
    setDiscriminator(discriminator) {
        this.discriminator = discriminator;
        return this;
    }
    getDiscriminator() {
        return this.discriminator;
    }
    setSearchOnContentLoaded(search) {
        this.searchOnContentLoaded = search;
        return this;
    }
    getSearchOnContentLoaded() {
        return this.searchOnContentLoaded;
    }
    setLiveResults(live) {
        this.liveResults = live;
        return this;
    }
    getLiveResults() {
        return this.liveResults;
    }
    setInitialInput(initialInput) {
        this.initialInput = initialInput;
        return this;
    }
    getInitialInput() {
        return this.initialInput;
    }
    setFillInputOnClick(fillInputOnClick) {
        this.fillInputOnClick = fillInputOnClick;
        return this;
    }
    getFillInputOnClick() {
        return this.fillInputOnClick;
    }
    setForceUseOfResult(forceUseOfresult) {
        this.forceUseOfResult = forceUseOfresult;
        return this;
    }
    getForceUseOfResult() {
        return this.forceUseOfResult;
    }
    setUseInResults(useInResults) {
        this.useInResults = useInResults;
        return this;
    }
    getUseInResults() {
        return this.useInResults;
    }
    setGroupBy(groupBy) {
        this.groupBy = groupBy;
        return this;
    }
    getGroupBy() {
        return this.groupBy;
    }
    setSortBy(sortBy) {
        this.sortBy = sortBy;
        return this;
    }
    getSortBy() {
        return this.sortBy;
    }
    setSortMode(sortMode) {
        this.sortMode = sortMode;
        return this;
    }
    getSortMode() {
        return this.sortMode;
    }
    setSortDirection(sortDirection) {
        if (this.allowedDirections.indexOf(sortDirection) === -1) {
            sortDirection = 'asc';
        }
        this.sortDirection = sortDirection;
        return this;
    }
    getSortDirection() {
        return this.sortDirection;
    }
    setShowBucket(showBucket) {
        this.showBucket = showBucket;
        return this;
    }
    getShowBucket() {
        return this.showBucket;
    }
    setBucketMapping(bucketMapping) {
        this.bucketMapping = bucketMapping;
        return this;
    }
    getBucketMapping() {
        return this.bucketMapping;
    }
    render(options = {}) {
        const template = this.getTemplate();
        options = Object.assign({ name: this.getQuery(), placeholder: this.getPlaceholder(), results: this.renderResults() }, options);
        const rendered = Mustache.render(template, options);
        return document.createRange().createContextualFragment(rendered);
    }
    renderResults(options = {}) {
        const template = this.getResultTemplate();
        options = Object.assign({ no_result_message: this.getNoResultMessage() }, options);
        return Mustache.render(template, options);
    }
    getQuery() {
        return this.query;
    }
    setQuery(query) {
        this.query = query;
        return this;
    }
    /**
     * Set listeners
     */
    executeJS() {
        const prevVal = URIHelper.getSearchParam(this.getQuery());
        document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-input`)
            .forEach((element) => {
            if (this.getForceUseOfResult()) {
                element.setAttribute('data-force', 'on');
            }
            element.value = (prevVal) ? prevVal : '';
            // On load call the handle function to trigger a search
            document.addEventListener('DOMContentLoaded', () => {
                if (this.getSearchOnContentLoaded()) {
                    this.handle(element);
                }
            });
            element.addEventListener('focus', () => {
                element.classList.add('active');
                Events.emit(Events.searchOpened, {
                    query: this.getQuery(),
                });
            });
            element.addEventListener('blur', () => {
                setTimeout(() => {
                    element.classList.remove('active');
                    Events.emit(Events.searchClosed, {
                        query: this.getQuery(),
                    });
                }, 100);
                if (this.getForceUseOfResult()) {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-result`);
                    if (results.length < 1) {
                        Events.emit(Events.onForceResultBlur, {
                            query: this.getQuery(),
                            value: null,
                        });
                        return;
                    }
                    if (this.selectedResult === -1 && element.value !== '') {
                        this.selectedResult = 0;
                        this.switchActiveClass(results);
                        element.value = results[this.selectedResult].getAttribute('data-attribute');
                        this.handleUrlChange(element);
                        Events.emit(Events.onForceResultBlur, {
                            query: this.getQuery(),
                            value: results[this.selectedResult].dataset,
                        });
                    }
                }
            });
            if (this.getInitialInput()) {
                element.addEventListener('input', (e) => {
                    // eslint-disable-next-line max-len
                    const initialInput = document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-result.needletail-initial-input`);
                    initialInput.forEach((r) => {
                        r.setAttribute('data-attribute', element.value);
                    });
                    element.setAttribute('data-initial-value', element.value);
                });
            }
            if (this.getUseDebounce()) {
                // If debounce is turned on
                element.addEventListener('input', _debounce(() => {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-result`);
                    this.selectedResult = -1;
                    this.switchActiveClass(results);
                    this.handle(element);
                }, this.getDebounceWait()));
                if (this.getInUrl()) {
                    // If the data should be saved in the URL
                    element.addEventListener('input', _debounce(() => {
                        this.handleUrlChange(element);
                    }, this.getDebounceUrlWait()));
                }
            }
            else {
                element.addEventListener('input', () => {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-result`);
                    this.selectedResult = -1;
                    this.switchActiveClass(results);
                    // If the data should be saved in the URL
                    this.handleUrlChange(element);
                    this.handle(element);
                });
            }
            element.addEventListener('keydown', (e) => {
                element.classList.add('active');
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-result`);
                    if (results.length < 1) {
                        return;
                    }
                    if (e.key === 'ArrowUp') {
                        // Move the active class up one
                        if (this.selectedResult > 0) {
                            this.selectedResult--;
                        }
                    }
                    else if (e.key === 'ArrowDown') {
                        // Move the active class down one
                        if (this.selectedResult < results.length - 1) {
                            this.selectedResult++;
                        }
                    }
                    this.switchActiveClass(results);
                    element.value = results[this.selectedResult].getAttribute('data-attribute');
                    if (this.getForceUseOfResult()) {
                        if (this.selectedResult < this.skipForceResults) {
                            element.setAttribute('data-force', 'on');
                        }
                        else {
                            element.setAttribute('data-force', 'off');
                        }
                    }
                    this.handleUrlChange(element);
                    Events.emit(Events.onArrowMovementSearch, {
                        query: this.getQuery(),
                        value: results[this.selectedResult].dataset,
                    });
                }
                else if (e.key === 'Enter') {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-autocomplete-bar-result`);
                    if (this.getForceUseOfResult()) {
                        if (element.getAttribute('data-force') === 'on') {
                            element.value = results[this.skipForceResults].getAttribute('data-attribute');
                            this.selectedResult = this.skipForceResults;
                        }
                    }
                    this.handleUrlChange(element);
                    // Handle on enter key and fire an event.
                    // this.handle(element);
                    Events.emit(Events.onSubmitSearch, {
                        query: this.getQuery(),
                        value: (results[this.selectedResult]) ? results[this.selectedResult].dataset : element.value,
                    });
                }
                else if (e.key === 'Escape') {
                    if (this.getInitialInput()) {
                        element.value = element.getAttribute('data-initial-value');
                    }
                    // Remove the focus on escape to close the dropdown
                    document.querySelectorAll(':focus').forEach((el) => el.blur());
                }
            });
        });
        document.addEventListener(Events.onBeforeSearch, (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.detail.query !== this.getQuery()) {
                e.preventDefault();
                return;
            }
            if (e.detail.value.length < this.getMinimumCharacters()) {
                e.preventDefault();
                return;
            }
            e.detail.extra_search_values = {};
            // Start the actual search
            Events.emit(Events.onSearch, e.detail);
        }));
        document.addEventListener(Events.onSearch, (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.detail.query !== this.getQuery()) {
                e.preventDefault();
                return;
            }
            let attributes = this.getAttributes();
            if (typeof attributes === 'string') {
                attributes = [attributes];
            }
            const search = [];
            attributes.forEach((attribute) => {
                search.push({
                    field: attribute,
                    value: e.detail.value,
                });
            });
            // Make the search
            const result = yield this.client.search({
                buckets: this.getBuckets(),
                search: Object.assign({ should: {
                        fuzzy: search,
                    } }, e.detail.extra_search_values),
                sort: this.getSortBy(),
                direction: this.getSortDirection(),
                size: this.getSize(),
                group_by: this.getGroupBy(),
                highlight: true,
                show_bucket: this.getShowBucket(),
                mode: this.getSortMode(),
            });
            e.detail.status = result.status;
            // If there is data map it to include some easy access values
            if (result && result.data.count > 0) {
                e.detail.search_result = result.data.results.map((r) => {
                    const bucketName = (r.bucket) ? r.bucket.toString() : '';
                    const mapped = Object.assign(Object.assign({ id: r.id }, r.record), { bucket: (bucketName !== '' && this.getBucketMapping()[bucketName]) ?
                            this.getBucketMapping()[bucketName] : '', value: {}, raw: {} });
                    if (r.highlight) {
                        mapped.highlight = {};
                    }
                    let attributes = this.getAttributes();
                    if (typeof attributes === 'string') {
                        attributes = [attributes];
                    }
                    attributes.forEach((attribute) => {
                        mapped.value[attribute] = r.record[attribute];
                        mapped.raw[attribute] = r.record[attribute];
                        if (r.highlight) {
                            mapped.highlight[attribute] = r.highlight[attribute];
                        }
                    });
                    return mapped;
                });
            }
            Events.emit(Events.onAfterSearch, e.detail);
        }));
        document.addEventListener(Events.onAfterSearch, (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.detail.query !== this.getQuery()) {
                e.preventDefault();
                return;
            }
            // Render the results
            // eslint-disable-next-line camelcase
            let options = {
                results: [],
                // eslint-disable-next-line camelcase
                initial_input: (this.getInitialInput()) ? e.detail.value : '',
            };
            if (e.detail.search_result && e.detail.search_result.length > 0 &&
                (e.detail.value && e.detail.value.length !== 0)) {
                options = {
                    results: e.detail.search_result,
                    initial_input: (this.getInitialInput()) ? e.detail.value : '',
                };
            }
            this.buildResults(options);
            Events.emit(Events.autocompleteBarFinished, {
                name: this.getDiscriminator(),
            });
        }));
    }
    buildResults(options = {}) {
        if (!this.getShowResults()) {
            return;
        }
        const results = this.renderResults(options);
        const nodeResults = document.createRange().createContextualFragment(results);
        document.querySelectorAll(`.needletail-autocomplete-bar-${this.getQuery()}`)
            .forEach((element) => __awaiter(this, void 0, void 0, function* () {
            const currentChild = element.querySelector('.needletail-autocomplete-bar-results');
            yield element.replaceChild(nodeResults.cloneNode(true), currentChild);
            const newChild = element.querySelector('.needletail-autocomplete-bar-results');
            const newResults = newChild.querySelectorAll('.needletail-autocomplete-bar-result');
            newResults.forEach((element) => {
                element.addEventListener('mouseover', (e) => {
                    this.selectedResult = Array.prototype.indexOf.call(newResults, element);
                    newResults.forEach((rElement) => {
                        rElement.classList.remove('active');
                    });
                    newResults[this.selectedResult].classList.add('active');
                });
                // Add the click event
                element.addEventListener('click', (e) => {
                    if (this.getFillInputOnClick()) {
                        // eslint-disable-next-line max-len
                        const inputs = document.querySelectorAll(`.needletail-autocomplete-bar-${this.getQuery()} .needletail-autocomplete-bar-input`);
                        inputs.forEach((i) => {
                            i.value = element.getAttribute('data-attribute');
                            this.handleUrlChange(i);
                        });
                    }
                    // this.handle(element);
                    Events.emit(Events.onSubmitSearch, {
                        query: this.getQuery(),
                        value: element.dataset,
                    });
                });
            });
            const input = element.querySelector('.needletail-autocomplete-bar-input');
            if (input && input.value.length > 0) {
                input.classList.remove('needletail-empty');
            }
        }));
    }
    handleUrlChange(element) {
        var _a;
        if (!this.getInUrl()) {
            return;
        }
        // Put the value in the url
        URIHelper.addToHistory(this.getQuery(), (_a = element.getAttribute('data-initial-value')) !== null && _a !== void 0 ? _a : element.value);
    }
    handle(element) {
        let data;
        const value = element.value;
        if (value && value.length < this.getMinimumCharacters()) {
            data = {
                value: '',
                search_result: {},
            };
            this.value = {
                field: this.getAttribute(),
                value: '',
            };
        }
        else {
            data = {
                value: value,
                search_result: {},
            };
            this.value = {
                field: this.getAttribute(),
                value: value,
            };
        }
        if (value.length == 0) {
            element.classList.add('needletail-empty');
        }
        data.query = this.getQuery();
        Events.emit(Events.onBeforeSearch, data);
        if (this.getLiveResults()) {
            Events.emit(Events.onBeforeResultRequest, {});
        }
    }
    switchActiveClass(results) {
        if (!this.getShowResults()) {
            return;
        }
        // Remove the active class from all results
        results.forEach((rElement) => {
            rElement.classList.remove('active');
        });
        if (this.selectedResult > -1) {
            // Add it to the new selected result
            results[this.selectedResult].classList.add('active');
        }
    }
}

var template$2 = "<div class=\"needletail-grouped-search-bar needletail-grouped-search-bar-{{ name }}\">\n    <input type=\"text\" class=\"needletail-grouped-search-bar-input needletail-empty\" autocomplete=\"off\" spellcheck=\"false\" placeholder=\"{{ placeholder }}\">\n    {{{ results }}}\n</div>";

var resultTemplate$1 = "<div class=\"needletail-grouped-search-bar-results\">\n    <div class=\"needletail-grouped-search-bar-result-results\">\n        {{#initial_input}}\n            <div class=\"needletail-grouped-search-bar-result needletail-initial-input\" data-attribute=\"{{ initial_input }}\">\n                {{{ initial_input }}}\n            </div>\n        {{/initial_input}}\n    </div>\n\n    {{#results}}\n        {{{ . }}}\n    {{/results}}\n    {{^results}}\n        <div class=\"needletail-grouped-search-bar-no-result\">\n            {{{ no_result_message }}}\n        </div>\n    {{/results}}\n</div>";

var defaultResultTemplate = "<div class=\"needletail-grouped-search-bar-result-title\">\n    {{ key }}\n</div>\n<div class=\"needletail-grouped-search-bar-result-results\">\n    {{#results}}\n        <div class=\"needletail-grouped-search-bar-result\" data-attribute=\"{{ raw.title }}\">\n            {{#highlight.title}}{{{ highlight.title }}}{{/highlight.title}}{{^highlight.title}}{{ title }}{{/highlight.title}}\n        </div>\n    {{/results}}\n</div>";

class GroupedSearchBar extends Widget {
    constructor(options = {}) {
        super(options);
        /**
         * The discriminator used for sorting the widget
         */
        this.discriminator = 'GroupedSearchBar';
        /**
         * Use debounce or not
         */
        this.debounce = true;
        /**
         * The time to wait for the debounce
         */
        this.debounceWait = 200;
        /**
         * The time to wait for the URL debounce
         */
        this.debounceUrlWait = 2000;
        /**
         * The name used in the URL for the field
         */
        this.query = 'groupedSearchBar';
        /**
         * Save the value in the url
         */
        this.inUrl = true;
        /**
         * Which buckets to search on
         */
        this.buckets = [];
        /**
         * The placeholder of the input field
         */
        this.placeholder = 'Start typing to search';
        /**
         * The message to show if there are no results
         */
        this.noResultMessage = 'No results where found';
        /**
         * The result that has the active class on it
         */
        this.selectedResult = -1;
        /**
         * The value to send to the search
         */
        this.value = {};
        /**
         * The amount of results to show
         */
        this.size = 3;
        /**
         * The minimum amount of characters before executing.
         */
        this.minimumCharacters = 3;
        this.groupBy = '';
        this.sortBy = '';
        this.sortDirection = 'asc';
        /**
         * Show the results below the search bar
         */
        this.showResults = true;
        this.searchOnContentLoaded = true;
        this.initialInput = true;
        this.fillInputOnClick = false;
        this.sortMode = 'min';
        this.allowedDirections = ['asc', 'desc'];
        this.setUseDebounce((typeof optional(options.debounce).use !== 'undefined') ?
            options.debounce.use : this.getUseDebounce());
        this.setDebounceWait(optional(options.debounce).wait || this.getDebounceWait());
        this.setDebounceUrlWait(optional(options.debounce).url_wait || this.getDebounceUrlWait());
        this.setInUrl((typeof options.in_url !== 'undefined') ?
            options.in_url : this.getInUrl());
        this.setQuery(options.query || this.getQuery());
        this.setAttribute(optional(options.search).attribute || '');
        this.setAttributes(optional(options.search).attributes || '');
        this.setBuckets(optional(options.search).buckets || []);
        this.setPlaceholder(options.placeholder || this.getPlaceholder());
        this.setNoResultMessage(options.no_result_message || this.getNoResultMessage());
        this.setSize(optional(options.search).size || this.getSize());
        this.setGroupBy(optional(options.search).group_by || '');
        this.setSortBy(optional(options.search).sort_by || '');
        this.setSortDirection(optional(options.search).sort_direction || this.getSortDirection());
        this.setSortMode(optional(options.search).sort_mode || this.getSortMode());
        this.setMinimumCharacters((typeof options.minimum_characters !== 'undefined') ?
            options.minimum_characters : this.getMinimumCharacters());
        this.setShowResults((typeof options.show_results !== 'undefined') ?
            options.show_results : this.getShowResults());
        this.setSearchOnContentLoaded((typeof options.search_on_content_loaded !== 'undefined') ?
            options.search_on_content_loaded : this.getSearchOnContentLoaded());
        this.setInitialInput((typeof options.initial_input !== 'undefined') ?
            options.initial_input : this.getInitialInput());
        this.setFillInputOnClick((typeof options.fill_input_on_click !== 'undefined') ?
            options.fill_input_on_click : this.getFillInputOnClick());
    }
    setMinimumCharacters(minimumCharacters) {
        this.minimumCharacters = minimumCharacters;
        return this;
    }
    getMinimumCharacters() {
        return this.minimumCharacters;
    }
    setSize(size) {
        this.size = size;
        return this;
    }
    getSize() {
        return this.size;
    }
    setPlaceholder(placeholder) {
        this.placeholder = placeholder;
        return this;
    }
    getPlaceholder() {
        return this.placeholder;
    }
    setNoResultMessage(noResultMessage) {
        this.noResultMessage = noResultMessage;
        return this;
    }
    getNoResultMessage() {
        return this.noResultMessage;
    }
    setAttribute(attribute) {
        this.attribute = attribute;
        return this;
    }
    getAttribute() {
        return this.attribute;
    }
    setAttributes(attribute) {
        if (this.attribute === '') {
            this.attribute = attribute;
        }
        return this;
    }
    getAttributes() {
        return this.attribute;
    }
    setBuckets(buckets) {
        this.buckets = buckets;
        return this;
    }
    getBuckets() {
        return this.buckets;
    }
    setUseDebounce(use = true) {
        this.debounce = use;
        return this;
    }
    getUseDebounce() {
        return this.debounce;
    }
    setDebounceWait(wait) {
        this.debounceWait = wait;
        return this;
    }
    getDebounceWait() {
        return this.debounceWait;
    }
    setDebounceUrlWait(wait) {
        this.debounceUrlWait = wait;
        return this;
    }
    getDebounceUrlWait() {
        return this.debounceUrlWait;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template$2;
    }
    setResultTemplate(template) {
        this.resultTemplate = template;
        return this;
    }
    getResultTemplate() {
        if (this.resultTemplate) {
            return this.resultTemplate;
        }
        return resultTemplate$1;
    }
    setInnerResultTemplate(template) {
        this.innerResultTemplate = template;
        return this;
    }
    getInnerResultTemplate() {
        if (this.innerResultTemplate) {
            return this.innerResultTemplate;
        }
        return defaultResultTemplate;
    }
    setInUrl(inUrl) {
        this.inUrl = inUrl;
        return this;
    }
    getInUrl() {
        return this.inUrl;
    }
    setShowResults(showResults) {
        this.showResults = showResults;
        return this;
    }
    getShowResults() {
        return this.showResults;
    }
    setDiscriminator(discriminator) {
        this.discriminator = discriminator;
        return this;
    }
    getDiscriminator() {
        return this.discriminator;
    }
    setSearchOnContentLoaded(search) {
        this.searchOnContentLoaded = search;
        return this;
    }
    getSearchOnContentLoaded() {
        return this.searchOnContentLoaded;
    }
    setInitialInput(initialInput) {
        this.initialInput = initialInput;
        return this;
    }
    getInitialInput() {
        return this.initialInput;
    }
    setGroupBy(groupBy) {
        this.groupBy = groupBy;
        return this;
    }
    getGroupBy() {
        return this.groupBy;
    }
    setSortBy(sortBy) {
        this.sortBy = sortBy;
        return this;
    }
    getSortBy() {
        return this.sortBy;
    }
    setSortMode(sortMode) {
        this.sortMode = sortMode;
        return this;
    }
    getSortMode() {
        return this.sortMode;
    }
    setSortDirection(sortDirection) {
        if (this.allowedDirections.indexOf(sortDirection) === -1) {
            sortDirection = 'asc';
        }
        this.sortDirection = sortDirection;
        return this;
    }
    getSortDirection() {
        return this.sortDirection;
    }
    setFillInputOnClick(fillInputOnClick) {
        this.fillInputOnClick = fillInputOnClick;
        return this;
    }
    getFillInputOnClick() {
        return this.fillInputOnClick;
    }
    render(options = {}) {
        const template = this.getTemplate();
        options = Object.assign({ name: this.getQuery(), placeholder: this.getPlaceholder(), results: this.renderResults() }, options);
        const rendered = Mustache.render(template, options);
        return document.createRange().createContextualFragment(rendered);
    }
    renderResults(options = {}) {
        const template = this.getResultTemplate();
        options = Object.assign({ no_result_message: this.getNoResultMessage() }, options);
        return Mustache.render(template, options);
    }
    renderResultTemplates(options = {}, template = null) {
        const use = (template) ? template : this.getInnerResultTemplate();
        return Mustache.render(use, options);
    }
    getQuery() {
        return this.query;
    }
    setQuery(query) {
        this.query = query;
        return this;
    }
    /**
     * Set listeners
     */
    executeJS() {
        const prevVal = URIHelper.getSearchParam(this.getQuery());
        document.querySelectorAll(`${this.getEl()} .needletail-grouped-search-bar-input`)
            .forEach((element) => {
            element.value = (prevVal) ? prevVal : '';
            // On load call the handle function to trigger a search
            document.addEventListener('DOMContentLoaded', () => {
                if (this.getSearchOnContentLoaded()) {
                    this.handle(element);
                }
            });
            element.addEventListener('focus', () => {
                element.classList.add('active');
                Events.emit(Events.groupedSearchOpened, {
                    query: this.getQuery(),
                });
            });
            element.addEventListener('blur', () => {
                setTimeout(() => {
                    element.classList.remove('active');
                    Events.emit(Events.groupedSearchClosed, {
                        query: this.getQuery(),
                    });
                }, 100);
            });
            if (this.getInitialInput()) {
                element.addEventListener('input', (e) => {
                    // eslint-disable-next-line max-len
                    const initialInput = document.querySelectorAll(`${this.getEl()} .needletail-grouped-search-bar-result.needletail-initial-input`);
                    initialInput.forEach((r) => {
                        const valueElement = r.querySelector('.needletail-initial-input-value');
                        if (valueElement) {
                            valueElement.innerHTML = element.value;
                        }
                        else {
                            r.innerHTML = element.value;
                        }
                        r.setAttribute('data-attribute', element.value);
                    });
                    element.setAttribute('data-initial-value', element.value);
                });
            }
            if (this.getUseDebounce()) {
                // If debounce is turned on
                element.addEventListener('input', _debounce(() => {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-grouped-search-bar-result`);
                    this.selectedResult = -1;
                    this.switchActiveClass(results);
                    this.handle(element);
                }, this.getDebounceWait()));
                if (this.getInUrl()) {
                    // If the data should be saved in the URL
                    element.addEventListener('input', _debounce(() => {
                        this.handleUrlChange(element);
                    }, this.getDebounceUrlWait()));
                }
            }
            else {
                element.addEventListener('input', () => {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-grouped-search-bar-result`);
                    this.selectedResult = -1;
                    this.switchActiveClass(results);
                    // If the data should be saved in the URL
                    this.handleUrlChange(element);
                    this.handle(element);
                });
            }
            element.addEventListener('keydown', (e) => {
                element.classList.add('active');
                if (e.key === 'ArrowUp' || e.key === 'ArrowDown') {
                    e.preventDefault();
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-grouped-search-bar-result`);
                    if (results.length < 1) {
                        return;
                    }
                    if (e.key === 'ArrowUp') {
                        // Move the active class up one
                        if (this.selectedResult > 0) {
                            this.selectedResult--;
                        }
                    }
                    else if (e.key === 'ArrowDown') {
                        // Move the active class down one
                        if (this.selectedResult < results.length - 1) {
                            this.selectedResult++;
                        }
                    }
                    this.switchActiveClass(results);
                    element.value = results[this.selectedResult].getAttribute('data-attribute');
                    Events.emit(Events.onArrowMovementGroupedSearch, {
                        query: this.getQuery(),
                        value: results[this.selectedResult].dataset,
                    });
                }
                else if (e.key === 'Enter') {
                    // eslint-disable-next-line max-len
                    const results = document.querySelectorAll(`${this.getEl()} .needletail-grouped-search-bar-result`);
                    // Handle on enter key and fire an event.
                    // this.handle(element);
                    Events.emit(Events.onSubmitGroupedSearch, {
                        query: this.getQuery(),
                        value: (results[this.selectedResult]) ? results[this.selectedResult].dataset : element.value,
                    });
                }
                else if (e.key === 'Escape') {
                    if (this.getInitialInput()) {
                        element.value = element.getAttribute('data-initial-value');
                    }
                    // Remove the focus on escape to close the dropdown
                    document.querySelectorAll(':focus').forEach((el) => el.blur());
                }
            });
        });
        document.addEventListener(Events.onBeforeGroupedSearch, (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.detail.query !== this.getQuery()) {
                e.preventDefault();
                return;
            }
            if (e.detail.value.length < this.getMinimumCharacters()) {
                e.preventDefault();
                return;
            }
            e.detail.extra_search_values = {};
            // Start the actual search
            Events.emit(Events.onGroupedSearch, e.detail);
        }));
        document.addEventListener(Events.onGroupedSearch, (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.detail.query !== this.getQuery()) {
                e.preventDefault();
                return;
            }
            const buckets = {};
            // Prepare the options for the search
            this.getBuckets().forEach((val) => {
                if (typeof val === 'object') {
                    if (val.name) {
                        let attributes = val.attribute || this.getAttributes();
                        if (typeof attributes === 'string') {
                            attributes = [attributes];
                        }
                        const search = [];
                        attributes.forEach((attribute) => {
                            search.push({
                                field: attribute,
                                value: e.detail.value,
                            });
                        });
                        buckets[val.name] = {
                            search: Object.assign({ should: {
                                    fuzzy: search,
                                } }, e.detail.extra_search_values),
                            sort: val.sort || this.getSortBy(),
                            direction: val.direction || this.getSortDirection(),
                            size: val.size || this.getSize(),
                            group_by: val.group_by || this.getGroupBy(),
                            highlight: true,
                            mode: val.sort_mode || this.getSortMode(),
                        };
                    }
                }
                else {
                    let attributes = this.getAttributes();
                    if (typeof attributes === 'string') {
                        attributes = [attributes];
                    }
                    const search = [];
                    attributes.forEach((attribute) => {
                        search.push({
                            field: attribute,
                            value: e.detail.value,
                        });
                    });
                    buckets[val] = {
                        search: Object.assign({ should: {
                                fuzzy: search,
                            } }, e.detail.extra_search_values),
                        sort: this.getSortBy(),
                        direction: this.getSortDirection(),
                        size: this.getSize(),
                        group_by: this.getGroupBy(),
                        highlight: true,
                        mode: this.getSortMode(),
                    };
                }
            });
            // Make the search
            const result = yield this.client.bulk({
                buckets: buckets,
            });
            e.detail.status = result.status;
            if (result && result.data) {
                e.detail.search_result = [];
                Object.keys(result.data).forEach((bucketKey) => {
                    var _a;
                    const r = result.data[bucketKey];
                    const bucket = this.getBuckets().find((b) => {
                        return (b.name === bucketKey || b === bucketKey);
                    });
                    // If there is data map it to include some easy access values
                    if (r.count > 0) {
                        e.detail.search_result.push({
                            raw: bucket,
                            key: (_a = bucket.key) !== null && _a !== void 0 ? _a : bucketKey,
                            results: r.results.map((r) => {
                                var _a;
                                const mapped = Object.assign(Object.assign({ id: r.id }, r.record), { value: {}, raw: {} });
                                if (r.highlight) {
                                    mapped.highlight = {};
                                }
                                let attributes = (_a = bucket.attribute) !== null && _a !== void 0 ? _a : this.getAttributes();
                                if (typeof attributes === 'string') {
                                    attributes = [attributes];
                                }
                                attributes.forEach((attribute) => {
                                    mapped.value[attribute] = r.record[attribute];
                                    mapped.raw[attribute] = r.record[attribute];
                                    if (r.highlight) {
                                        mapped.highlight[attribute] = r.highlight[attribute];
                                    }
                                });
                                return mapped;
                            }),
                        });
                    }
                });
            }
            Events.emit(Events.onAfterGroupedSearch, e.detail);
        }));
        document.addEventListener(Events.onAfterGroupedSearch, (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.detail.query !== this.getQuery()) {
                e.preventDefault();
                return;
            }
            // Render the results
            let options = {
                initial_input: (this.getInitialInput()) ? e.detail.value : '',
            };
            if (e.detail.search_result && Object.keys(e.detail.search_result).length > 0) {
                options = {
                    results: e.detail.search_result,
                    initial_input: (this.getInitialInput()) ? e.detail.value : '',
                };
            }
            this.buildResults(options);
            Events.emit(Events.groupedSearchBarFinished, {
                name: this.getDiscriminator(),
            });
        }));
    }
    buildResults(options = {}) {
        if (!this.getShowResults()) {
            return;
        }
        const innerResults = [];
        if (options && options.results) {
            options.results.forEach((r) => {
                const bucket = this.getBuckets().find((b) => {
                    return (b.key === r.key || b === r.key);
                });
                if (bucket && bucket.template) {
                    innerResults.push(this.renderResultTemplates(r, bucket.template));
                }
                else {
                    innerResults.push(this.renderResultTemplates(r));
                }
            });
            options.results = innerResults;
        }
        const results = this.renderResults(options);
        const nodeResults = document.createRange().createContextualFragment(results);
        document.querySelectorAll(`.needletail-grouped-search-bar-${this.getQuery()}`)
            .forEach((element) => {
            const currentChild = element.querySelector('.needletail-grouped-search-bar-results');
            element.replaceChild(nodeResults.cloneNode(true), currentChild);
            const newChild = element.querySelector('.needletail-grouped-search-bar-results');
            const newResults = newChild.querySelectorAll('.needletail-grouped-search-bar-result');
            newResults.forEach((element) => {
                element.addEventListener('mouseover', (e) => {
                    this.selectedResult = Array.prototype.indexOf.call(newResults, element);
                    newResults.forEach((rElement) => {
                        rElement.classList.remove('active');
                    });
                    newResults[this.selectedResult].classList.add('active');
                });
                // Add the click event
                element.addEventListener('click', (e) => {
                    if (this.getFillInputOnClick()) {
                        // eslint-disable-next-line max-len
                        const inputs = document.querySelectorAll(`.needletail-grouped-search-bar-${this.getQuery()} .needletail-grouped-search-bar-input`);
                        inputs.forEach((i) => {
                            i.value = element.getAttribute('data-attribute');
                            this.handleUrlChange(i);
                        });
                    }
                    // this.handle(element);
                    Events.emit(Events.onSubmitGroupedSearch, {
                        query: this.getQuery(),
                        value: element.dataset,
                    });
                });
            });
            const input = element.querySelector('.needletail-grouped-search-bar-input');
            if (input && input.value.length > 0) {
                input.classList.remove('needletail-empty');
            }
        });
    }
    handleUrlChange(element) {
        if (!this.getInUrl()) {
            return;
        }
        // Put the value in the url
        URIHelper.addToHistory(this.getQuery(), element.getAttribute('data-initial-value'));
    }
    handle(element) {
        let data;
        const value = element.value;
        if (value && value.length < this.getMinimumCharacters()) {
            data = {
                value: '',
                search_result: {},
            };
            this.value = {
                field: this.getAttributes(),
                value: '',
            };
        }
        else {
            data = {
                value: value,
                search_result: {},
            };
            this.value = {
                field: this.getAttributes(),
                value: value,
            };
        }
        if (value.length == 0) {
            element.classList.add('needletail-empty');
        }
        data.query = this.getQuery();
        Events.emit(Events.onBeforeGroupedSearch, data);
    }
    switchActiveClass(results) {
        if (!this.getShowResults()) {
            return;
        }
        // Remove the active class from all results
        results.forEach((rElement) => {
            rElement.classList.remove('active');
        });
        if (this.selectedResult > -1) {
            // Add it to the new selected result
            results[this.selectedResult].classList.add('active');
        }
    }
}

var template$1 = "<div class=\"needletail-result\">\n    <div class=\"needletail-total-results\">\n        {{ total_results_text }}\n    </div>\n    {{#use_sort_select}}\n        {{{ sort_select }}}\n    {{/use_sort_select}}\n    <div class=\"needletail-result-results {{ hide_on_initial_request }}\">\n        {{{results}}}\n    </div>\n    {{#infinite_scroll}}\n    <div class=\"needletail-loader infinity-scroll\"></div>\n    {{/infinite_scroll}}\n\n    <div class=\"needletail-result-pagination {{ hide_pagination }}\">\n        {{#first_button}}\n            <div class=\"needletail-result-pagination-page needletail-result-pagination-first {{ disable_first_button }}\" data-page=\"{{ first_page }}\">{{{ first_button }}}</div>\n        {{/first_button}}\n        <div class=\"needletail-result-pagination-page needletail-result-pagination-previous {{ disable_previous_button }}\" data-page=\"{{ previous_page }}\">{{{ previous_button }}}</div>\n        {{#pages}}\n            <div class=\"needletail-result-pagination-page {{active}}\" data-offset=\"{{offset}}\" data-page=\"{{page}}\">\n                {{page}}\n            </div>\n        {{/pages}}\n        <div class=\"needletail-result-pagination-page needletail-result-pagination-next {{ disable_next_button }}\" data-page=\"{{ next_page }}\">{{{ next_button }}}</div>\n        {{#last_button}}\n            <div class=\"needletail-result-pagination-page needletail-result-pagination-last {{ disable_last_button }}\" data-page=\"{{ last_page }}\">{{{ last_button }}}</div>\n        {{/last_button}}\n    </div>\n</div>\n";

var resultTemplate = "{{#results}}\n    <div class=\"needletail-result-result\">\n        <div class=\"needletail-result-title\">{{ title }}</div>\n        <div class=\"needletail-result-body\">{{ body }}</div>\n    </div>\n{{/results}}\n{{^results}}\n    <div class=\"needletail-result-no-result\">\n        {{{ no_result_message }}}\n    </div>\n{{/results}}";

var resultSortSelect = "<select class=\"needletail-sort-select\">\n    {{#options}}\n        <option value=\"{{ name }}\" data-attribute=\"{{ attribute }}\" data-direction=\"{{ direction }}\">{{#display_name}}{{{ display_name }}}{{/display_name}}{{^display_name}}{{ name }}{{/display_name}}</option>\n    {{/options}}\n</select>";

var resultSkeletonTemplate = "<div class=\"needletail-skeleton needletail-result\">\n    <div class=\"needletail-skeleton needletail-skeleton-spacing needletail-skeleton-spacing--l needletail-total-results\">\n        <h3 class=\"needletail-skeleton-header\">\n            <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n        </h3>\n    </div>\n    <ul class=\"needletail-skeleton-spacing needletail-skeleton-spacing--l\">\n        {{#records}}\n            <li class=\"needletail-skeleton-base\">\n                <div class=\"needletail-skeleton-media\">\n                    <span class=\"needletail-skeleton-box\" style=\"width:100px;height:100px;\"></span>\n                </div>\n                <div class=\"needletail-skeleton-body\">\n                    <div class=\"needletail-skeleton-spacing\">\n                        <h3 class=\"needletail-skeleton-header\">\n                            <span class=\"needletail-skeleton-box\" style=\"width:55%;\"></span>\n                        </h3>\n                        <p>\n                            <span class=\"needletail-skeleton-box\" style=\"width:80%;\"></span>\n                            <span class=\"needletail-skeleton-box\" style=\"width:90%;\"></span>\n                            <span class=\"needletail-skeleton-box\" style=\"width:83%;\"></span>\n                            <span class=\"needletail-skeleton-box\" style=\"width:80%;\"></span>\n                        </p>\n                    </div>\n                </div>\n            </li>\n        {{/records}}\n    </ul>\n</div>\n";

class Result extends Widget {
    constructor(options = {}) {
        super(options);
        /**
         * The template used for the result dropdown
         */
        this.discriminator = 'Result';
        /**
         * The amount of records to show per page
         */
        this.perPage = 10;
        /**
         * The text for the previous button
         */
        this.previous = 'Previous';
        /**
         * The text for the next button
         */
        this.next = 'Next';
        /**
         * The text for the last button
         */
        this.last = 'Last';
        /**
         * The text for the first button
         */
        this.first = 'First';
        /**
         * Enable or disable the first and last button
         */
        this.showQuickPagination = false;
        /**
         * The amount of pages to show at the same time, this excludes the first and last page
         */
        this.minifyPages = 5;
        this.groupBy = '';
        this.sortBy = '';
        // eslint-disable-next-line camelcase
        this.sortSelect = {};
        this.sortDirection = '';
        this.noResultMessage = 'No results where found';
        this.initialRequest = true;
        this.scrollOffset = 100;
        this.scrollBackToTop = true;
        this.buckets = [];
        this.sortMode = 'min';
        this.allowedDirections = ['asc', 'desc'];
        this.activeClass = 'active';
        this.hideOnSinglePage = true;
        this.hidePagination = false;
        this.query = 'result';
        this.infiniteScroll = false;
        this.infinityPage = 1;
        this.hardReset = false;
        this.totalPages = 1;
        this.bottomScrollOffset = 0;
        this.loader = null;
        this.allowedLoaders = ['round-dots', 'round-line', 'straight-bars', 'straight-dots'];
        this.totalResults = 0;
        this.totalResultsText = ':count total results';
        this.extraOptions = {};
        this.useSkeleton = false;
        this.setQuery(options.query || this.getQuery());
        this.setPerPage(options.per_page || this.getPerPage());
        this.setPrevious(optional(options.pagination).previous || this.getPrevious());
        this.setNext(optional(options.pagination).next || this.getNext());
        this.setMinifyPages(options.minify_pages || this.getMinifyPages());
        this.setLast(optional(options.pagination).last || this.getLast());
        this.setFirst(optional(options.pagination).first || this.getFirst());
        this.setShowQuickPagination((typeof optional(options.pagination).show_quick_pagination !== 'undefined') ?
            options.pagination.show_quick_pagination : this.getShowQuickPagination());
        this.setScrollOffset(optional(options.pagination).scroll_offset || this.getScrollOffset());
        this.setScrollBackToTop((typeof optional(options.pagination).scroll_back_to_top !== 'undefined') ?
            options.pagination.scroll_back_to_top : this.getScrollBackToTop());
        this.setHideOnSinglePage((typeof optional(options.pagination).hide_on_single_page !== 'undefined') ?
            options.pagination.hide_on_single_page : this.getHideOnSinglePage());
        this.setResultTemplate(options.result_template);
        this.setGroupBy(options.group_by || '');
        this.setSortSelect(options.sort_select || {});
        this.setSortSelectDefault(URIHelper.getSearchParam('default') || options.sort_select_default || '');
        this.setSortBy(URIHelper.getSearchParam('sort') || options.sort_by || '');
        this.setSortDirection(URIHelper.getSearchParam('direction') || options.sort_direction || this.getSortDirection());
        this.setSortMode(options.sort_mode || this.getSortMode());
        this.setNoResultMessage(options.no_result_message || this.getNoResultMessage());
        this.setBuckets(options.buckets || []);
        this.setPaginationActiveClass(optional(options.pagination).active_class || this.getPaginationActiveClass());
        this.setInfiniteScroll(optional(options.pagination).infinite_scroll || this.getInfiniteScroll());
        this.setBottomScrollOffset(optional(options.pagination).bottom_scroll_offset || this.getBottomScrollOffset());
        this.setLoader(options.loader || this.getLoader());
        this.setTotalResultsText(options.total_results_text || this.getTotalResultsText());
        this.setExtraOptions(options.extra_options || {});
        this.setUseSkeleton((typeof optional(options).use_skeleton !== 'undefined') ?
            optional(options).use_skeleton : this.getUseSkeleton());
        this.setResultSkeletonTemplate(optional(options).skeleton_template || this.getResultSkeletonTemplate());
    }
    getUseSkeleton() {
        return this.useSkeleton;
    }
    setUseSkeleton(useSkeleton) {
        this.useSkeleton = useSkeleton;
        return this;
    }
    getResultSkeletonTemplate() {
        if (this.resultSkeletonTemplate) {
            return this.resultSkeletonTemplate;
        }
        return resultSkeletonTemplate;
    }
    setResultSkeletonTemplate(template) {
        this.resultSkeletonTemplate = template;
        return this;
    }
    getQuery() {
        return this.query;
    }
    setQuery(query) {
        this.query = query;
        return this;
    }
    getTotalResults() {
        return this.totalResults;
    }
    setTotalResults(totalResults) {
        this.totalResults = totalResults;
        return this;
    }
    getTotalResultsText() {
        var _a;
        const count = (_a = this.getTotalResults()) !== null && _a !== void 0 ? _a : 0;
        let copy = this.totalResultsText;
        copy = copy.replace(/:count/ig, count.toString());
        const split = copy.split('|');
        if (split.length === 0) {
            return copy;
        }
        const singleRegex = /^{(\d+)} (.+)/;
        const multiRegex = /^\[(\d+),(\d+|\*)] (.+)/;
        let final = copy;
        split.forEach((s) => {
            const singleMatch = singleRegex.exec(s);
            if (singleMatch) {
                if (count === parseInt(singleMatch[1])) {
                    final = singleMatch[2];
                }
            }
            const multiMatch = multiRegex.exec(s);
            if (multiMatch) {
                let infinite = false;
                if (multiMatch[2] === '*') {
                    infinite = true;
                }
                if (count >= parseInt(multiMatch[1]) && (count <= parseInt(multiMatch[2]) || infinite)) {
                    final = multiMatch[3];
                }
            }
        });
        return final;
    }
    setTotalResultsText(totalResultsText) {
        this.totalResultsText = totalResultsText;
        return this;
    }
    getInfiniteScroll() {
        return this.infiniteScroll;
    }
    setInfiniteScroll(infiniteScroll) {
        this.infiniteScroll = infiniteScroll;
        return this;
    }
    getBottomScrollOffset() {
        return this.bottomScrollOffset;
    }
    setBottomScrollOffset(bottomScrollOffset) {
        this.bottomScrollOffset = bottomScrollOffset;
        return this;
    }
    getLoader() {
        return this.loader;
    }
    setLoader(loader) {
        if (this.allowedLoaders.indexOf(loader) !== -1) {
            this.loader = loader;
        }
        return this;
    }
    setHideOnSinglePage(hideOnSinglePage) {
        this.hideOnSinglePage = hideOnSinglePage;
        return this;
    }
    getHideOnSinglePage() {
        return this.hideOnSinglePage;
    }
    setPaginationActiveClass(activeClass) {
        this.activeClass = activeClass;
        return this;
    }
    getPaginationActiveClass() {
        return this.activeClass;
    }
    setBuckets(buckets) {
        this.buckets = buckets;
        return this;
    }
    getBuckets() {
        return this.buckets;
    }
    setScrollBackToTop(scrollBackToTop) {
        this.scrollBackToTop = scrollBackToTop;
        return this;
    }
    getScrollBackToTop() {
        return this.scrollBackToTop;
    }
    setScrollOffset(scrollOffset) {
        this.scrollOffset = scrollOffset;
        return this;
    }
    getScrollOffset() {
        return this.scrollOffset;
    }
    setPerPage(perPage) {
        this.perPage = perPage;
        return this;
    }
    getPerPage() {
        return this.perPage;
    }
    setShowQuickPagination(showQuickPagination) {
        this.showQuickPagination = showQuickPagination;
        return this;
    }
    getShowQuickPagination() {
        return this.showQuickPagination;
    }
    setMinifyPages(minifyPages) {
        this.minifyPages = minifyPages;
        return this;
    }
    getMinifyPages() {
        return this.minifyPages;
    }
    setPrevious(previous) {
        this.previous = previous;
        return this;
    }
    getPrevious() {
        return this.previous;
    }
    setNext(next) {
        this.next = next;
        return this;
    }
    getNext() {
        return this.next;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template$1;
    }
    getResultTemplate() {
        if (this.resultTemplate) {
            return this.resultTemplate;
        }
        return resultTemplate;
    }
    setResultTemplate(template) {
        this.resultTemplate = template;
        return this;
    }
    setResultSortSelectTemplate(template) {
        this.sortSelectTemplate = template;
        return this;
    }
    getResultSortSelectTemplate() {
        if (this.sortSelectTemplate) {
            return this.sortSelectTemplate;
        }
        return resultSortSelect;
    }
    setFirst(first) {
        this.first = first;
        this.setShowQuickPagination(true);
        return this;
    }
    getFirst() {
        return this.first;
    }
    setLast(last) {
        this.last = last;
        this.setShowQuickPagination(true);
        return this;
    }
    getLast() {
        return this.last;
    }
    setGroupBy(groupBy) {
        this.groupBy = groupBy;
        return this;
    }
    getGroupBy() {
        return this.groupBy;
    }
    setSortBy(sortBy) {
        if (sortBy === '' && (Object.keys(this.getSortSelect()).length > 0)) {
            for (const key in this.getSortSelect()) {
                if (this.getSortSelect()[key].name === this.getSortSelectDefault()) {
                    sortBy = this.getSortSelect()[key].attribute || '';
                }
            }
        }
        this.sortBy = sortBy;
        return this;
    }
    getSortBy() {
        return this.sortBy;
    }
    setSortMode(sortMode) {
        this.sortMode = sortMode;
        return this;
    }
    getSortMode() {
        return this.sortMode;
    }
    setSortDirection(sortDirection) {
        if (sortDirection === '' && (Object.keys(this.getSortSelect()).length > 0)) {
            for (const key in this.getSortSelect()) {
                if (this.getSortSelect()[key].name === this.getSortSelectDefault()) {
                    sortDirection = this.getSortSelect()[key].direction || '';
                }
            }
        }
        if (this.allowedDirections.indexOf(sortDirection) === -1) {
            sortDirection = 'asc';
        }
        this.sortDirection = sortDirection;
        return this;
    }
    getSortDirection() {
        return this.sortDirection;
    }
    // eslint-disable-next-line max-len,camelcase
    setSortSelect(sortSelect) {
        this.sortSelect = sortSelect;
        return this;
    }
    // eslint-disable-next-line camelcase
    getSortSelect() {
        return this.sortSelect;
    }
    setSortSelectDefault(sortSelectDefault) {
        this.sortSelectDefault = sortSelectDefault;
        return this;
    }
    getSortSelectDefault() {
        return this.sortSelectDefault;
    }
    setNoResultMessage(noResultMessage) {
        this.noResultMessage = noResultMessage;
        return this;
    }
    getNoResultMessage() {
        return this.noResultMessage;
    }
    setExtraOptions(options) {
        this.extraOptions = options;
        return this;
    }
    getExtraOptions() {
        return this.extraOptions;
    }
    renderResultSkeleton() {
        const options = {
            records: new Array(this.getPerPage()).fill(null),
        };
        const rendered = Mustache.render(this.getResultSkeletonTemplate(), options);
        return document.createRange().createContextualFragment(rendered);
    }
    // eslint-disable-next-line max-len
    render(results = [], pages = [], firstRender = true) {
        const template = this.getTemplate();
        const mappedResults = [];
        if (results) {
            Object.keys(results).forEach((key) => {
                mappedResults.push(Object.assign({ id: results[key].id }, results[key].record));
            });
        }
        // If the page does not exist, assume we're on the first page
        const currentPage = parseInt(URIHelper.getSearchParam('page')) || 1;
        const lastPage = pages[pages.length - 1];
        const options = {
            previous_button: this.getPrevious(),
            next_button: this.getNext(),
            previous_page: currentPage - 1,
            next_page: currentPage + 1,
            // Disable it if there are no pages or the current page is 1
            disable_previous_button: (pages.length === 0 ||
                currentPage === 1) ? 'disabled' : '',
            // Disable it if there are no pages or the current page is the last page
            disable_next_button: (pages.length === 0 ||
                lastPage.page === currentPage) ? 'disabled' : '',
            pages: pages,
            results: this.renderResults({
                results: mappedResults,
                no_result_message: this.getNoResultMessage(),
            }),
            last_button: '',
            first_button: '',
            first_page: 0,
            last_page: 0,
            // Disable it if there are no pages or the current page is the last page
            disable_last_button: (pages.length === 0 ||
                lastPage.page === currentPage) ? 'disabled' : '',
            // Disable it if there are no pages or the current page is 1
            disable_first_button: (pages.length === 0 ||
                currentPage === 1) ? 'disabled' : '',
            use_sort_select: (Object.keys(this.getSortSelect()).length > 0),
            sort_select: this.renderSortSelect({
                options: this.getSortSelect(),
            }),
            hide_pagination: (this.hidePagination || this.getInfiniteScroll()) ? 'needletail-hidden' : '',
            hide_on_initial_request: (firstRender) ? 'needletail-hide-on-initial-request' : '',
            infinite_scroll: this.getInfiniteScroll(),
            total_results: this.getTotalResults(),
            total_results_text: this.getTotalResultsText(),
            extra_options: this.getExtraOptions(),
        };
        // Enable the quick navigation
        if (this.getShowQuickPagination()) {
            options.last_button = this.getLast();
            options.first_button = this.getFirst();
            options.first_page = 1;
            options.last_page = optional(lastPage).page;
        }
        const rendered = Mustache.render(template, options);
        return document.createRange().createContextualFragment(rendered);
    }
    renderResults(options = {}) {
        const template = this.getResultTemplate();
        options = Object.assign({}, options);
        return Mustache.render(template, options);
    }
    renderSortSelect(options = {}) {
        const template = this.getResultSortSelectTemplate();
        options = Object.assign({}, options);
        return Mustache.render(template, options);
    }
    executeJS() {
        document.addEventListener(Events.onBeforeResultRequest, _debounce((e) => {
            if (!e.detail.query) {
                e.detail.query = this.getQuery();
            }
            if (this.getUseSkeleton()) {
                const skeletonNode = this.renderResultSkeleton();
                document.querySelectorAll(this.getEl()).forEach((element) => {
                    const child = element.querySelector('.needletail-result');
                    element.replaceChild(skeletonNode.cloneNode(true), child);
                });
            }
            const autocompleteBars = this.client.widgets.autocompleteBar;
            const aggregationBars = this.client.widgets.aggregationBar;
            // Build the options for the search
            let buckets = autocompleteBars.reduce((res, bar) => {
                if (!bar.getUseInResults()) {
                    return res;
                }
                bar.getBuckets().forEach((bucket) => {
                    res.push(bucket);
                });
                return res;
            }, []);
            buckets = buckets.concat(this.getBuckets());
            const autocompleteValues = autocompleteBars.reduce((res, bar) => {
                if (!bar.getUseInResults()) {
                    return res;
                }
                if (Object.keys(bar.value).length > 0) {
                    if (typeof bar.value.field === 'string') {
                        res.push(bar.value);
                    }
                    else {
                        bar.value.field.forEach((field) => {
                            res.push({
                                field: field,
                                value: bar.value.value,
                            });
                        });
                    }
                }
                return res;
            }, []);
            const aggregationValues = aggregationBars.map((bar) => {
                return bar.getValues();
            });
            e.detail.buckets = buckets;
            e.detail.search_values = {};
            e.detail.equals_search_values = {
                'match': [
                    // eslint-disable-next-line prefer-spread
                    ...[].concat.apply([], aggregationValues),
                ],
            };
            e.detail.extra_search_values = {};
            e.detail.should_search_values = {
                'fuzzy': [
                    // eslint-disable-next-line prefer-spread
                    ...[].concat.apply([], autocompleteValues),
                ],
            };
            Events.emit(Events.onResultRequest, e.detail);
        }, 100));
        document.addEventListener(Events.onResultRequest, _debounce((e) => __awaiter(this, void 0, void 0, function* () {
            let currentPage = 1;
            let size = this.getPerPage();
            let offset;
            if (this.initialRequest) {
                this.infinityPage = parseInt(URIHelper.getSearchParam('page')) || 1;
            }
            if (this.getInfiniteScroll()) {
                currentPage = this.infinityPage;
                offset = (currentPage - 1) * this.getPerPage();
                if (this.initialRequest) {
                    size *= currentPage;
                    offset = 0;
                }
            }
            else {
                // If there is no page, assume we're on page 1
                currentPage = parseInt(URIHelper.getSearchParam('page')) || 1;
                offset = (currentPage - 1) * this.getPerPage();
            }
            // Perform the search
            const result = yield this.client.search({
                buckets: e.detail.buckets,
                search: Object.assign({ 'should': Object.assign({}, e.detail.should_search_values), 'equals': Object.assign(Object.assign({}, e.detail.search_values), e.detail.equals_search_values) }, e.detail.extra_search_values),
                size: size,
                mode: this.getSortMode(),
                group_by: this.getGroupBy(),
                sort: this.getSortBy(),
                direction: this.getSortDirection(),
                offset: offset,
            });
            e.detail.status = result.status;
            if (result && result.data) {
                e.detail.count = result.data.count;
                this.setTotalResults(e.detail.count);
                if (result.data.results) {
                    e.detail.pages = [];
                    // Add all the pages
                    for (let i = 0; i < Math.ceil(result.data.count / this.getPerPage()); i++) {
                        e.detail.pages.push({
                            page: (i + 1),
                            offset: i * this.getPerPage(),
                            active: ((i === 0 && !currentPage) ||
                                currentPage === (i + 1)) ? this.getPaginationActiveClass() : '',
                        });
                    }
                    const totalPages = e.detail.pages.length;
                    this.totalPages = totalPages;
                    if (totalPages === 1 && this.getHideOnSinglePage()) {
                        this.hidePagination = true;
                    }
                    else {
                        this.hidePagination = false;
                    }
                    // If there's more pages than the user wants to show start minifying
                    if (totalPages > this.getMinifyPages()) {
                        let start = 0;
                        const startArray = [];
                        const endArray = [];
                        let halfMinified = Math.ceil(this.getMinifyPages() / 2);
                        let takeFull = false;
                        // Get the last page and add a separator
                        if (totalPages - halfMinified >= currentPage) {
                            const last = e.detail.pages.pop();
                            // Separator
                            if (totalPages - halfMinified != currentPage) {
                                endArray.push({
                                    page: '...',
                                    offset: 0,
                                    active: 'disabled',
                                });
                            }
                            endArray.push(last);
                        }
                        else {
                            takeFull = true;
                        }
                        if (halfMinified < currentPage) {
                            const first = e.detail.pages.shift();
                            startArray.push(first);
                            // If the minify pages is an uneven number add 1 to the half minified
                            if (this.getMinifyPages() % 2 === 1) {
                                halfMinified++;
                            }
                            if (takeFull) {
                                let take = this.getMinifyPages();
                                // If the current page is the last page, minus one
                                if (currentPage == totalPages) {
                                    currentPage--;
                                    // If the current page is the second to last page, take half instead of full
                                }
                                else if (currentPage == (totalPages - 2)) {
                                    take = halfMinified;
                                }
                                start = currentPage - take;
                            }
                            else {
                                start = currentPage - halfMinified;
                            }
                            if (start > 0) {
                                // Separator
                                startArray.push({
                                    page: '...',
                                    offset: 0,
                                    active: 'disabled',
                                });
                            }
                        }
                        const items = e.detail.pages.splice(start, this.getMinifyPages());
                        e.detail.pages = [
                            ...items,
                        ];
                        if (startArray.length > 0) {
                            e.detail.pages.unshift(...startArray);
                        }
                        if (endArray.length > 0) {
                            e.detail.pages.push(...endArray);
                        }
                    }
                    e.detail.search_result = result.data.results;
                }
                if (result.data.aggs) {
                    Events.emit(Events.onAggsUpdate, result.data.aggs);
                }
            }
            Events.emit(Events.onAfterResultRequest, e.detail);
        }), 100));
        document.addEventListener(Events.onPageChange, (e) => {
            if (!this.initialRequest && this.getScrollBackToTop()) {
                const elements = document.querySelectorAll(this.getEl());
                if (elements.length === 1) {
                    const element = elements.item(0);
                    const position = element.offsetTop;
                    const offsetPosition = position - this.getScrollOffset();
                    window.scrollTo({
                        top: offsetPosition,
                        behavior: 'smooth',
                    });
                }
            }
        });
        document.addEventListener(Events.onAfterResultRequest, (e) => {
            // Render the node
            const node = this.render(e.detail.search_result, e.detail.pages, false);
            document.querySelectorAll(this.getEl()).forEach((element) => {
                const child = element.querySelector('.needletail-result');
                if (this.getInfiniteScroll()) {
                    const lastItems = child.querySelectorAll('.needletail-result-result');
                    const lastItem = lastItems[lastItems.length - 1];
                    if (lastItem && !this.hardReset) {
                        let resultChild;
                        node.childNodes.forEach((childNode) => {
                            if (childNode.classList &&
                                childNode.classList.contains('needletail-result') &&
                                !resultChild) {
                                resultChild = childNode.querySelector('.needletail-result-results');
                            }
                        });
                        lastItem.after(...resultChild.childNodes);
                    }
                    else {
                        element.replaceChild(node.cloneNode(true), child);
                        this.hardReset = false;
                    }
                }
                else {
                    element.replaceChild(node.cloneNode(true), child);
                    element.querySelectorAll('.needletail-result-pagination-page:not(.disabled):not(.active)')
                        .forEach((paginationElement) => {
                        // Add the click event
                        paginationElement.addEventListener('click', (e) => {
                            const currentPage = URIHelper.getSearchParam('page');
                            const pageNumber = paginationElement.getAttribute('data-page');
                            URIHelper.addToHistory('page', pageNumber);
                            Events.emit(Events.onPageChange, {
                                current_page: currentPage,
                                new_page: pageNumber,
                            });
                            Events.emit(Events.onBeforeResultRequest, {
                                query: this.getQuery(),
                            });
                        });
                    });
                }
            });
            const sortSelect = document.getElementsByClassName('needletail-sort-select');
            for (let i = 0; i < sortSelect.length; i++) {
                sortSelect[i].value = this.getSortSelectDefault();
                sortSelect[i].addEventListener('change', (e) => {
                    this.setSortSelectDefault(e.target.value);
                    this.setSortBy(e.target.options[e.target.selectedIndex].getAttribute('data-attribute'));
                    this.setSortDirection(e.target.options[e.target.selectedIndex].getAttribute('data-direction') || 'asc');
                    URIHelper.addToHistory('page', '1');
                    URIHelper.addToHistory('direction', this.getSortDirection());
                    URIHelper.addToHistory('sort', this.getSortBy());
                    URIHelper.addToHistory('default', this.getSortSelectDefault());
                    this.infinityPage = 1;
                    this.hardReset = true;
                    Events.emit(Events.onBeforeResultRequest, {
                        query: this.getQuery(),
                    });
                });
            }
            const elements = document.querySelectorAll('.needletail-result-result');
            elements.forEach((element, index) => {
                element.addEventListener('click', (e) => {
                    URIHelper.addToHistory('index', index.toString());
                });
            });
            if (this.initialRequest && URIHelper.getSearchParam('index') !== null) {
                const element = elements.item(parseInt(URIHelper.getSearchParam('index')));
                if (element) {
                    const position = element.offsetTop;
                    const offsetPosition = position - this.getScrollOffset();
                    window.scrollTo({
                        top: offsetPosition,
                        behavior: this.getInfiniteScroll() ? 'smooth' : 'auto',
                    });
                }
            }
            this.stopLoader('infinity-scroll');
            this.initialRequest = false;
            Events.emit(Events.resultFinished, {
                name: this.discriminator,
            });
        });
        if (this.getInfiniteScroll()) {
            window.addEventListener('scroll', _debounce(() => {
                const { scrollTop, scrollHeight, clientHeight, } = document.documentElement;
                if (scrollTop + clientHeight >= scrollHeight - this.getBottomScrollOffset() &&
                    this.totalPages >= this.infinityPage + 1) {
                    this.infinityPage++;
                    URIHelper.addToHistory('page', this.infinityPage.toString());
                    this.startLoader('infinity-scroll');
                    Events.emit(Events.onBeforeResultRequest, {
                        query: this.getQuery(),
                    });
                }
            }, 200));
        }
        document.addEventListener(Events.onAggregationValueChange, (e) => {
            if (!this.initialRequest) {
                URIHelper.addToHistory('page', '1');
                this.infinityPage = 1;
                this.hardReset = true;
            }
        });
        Events.emit(Events.onBeforeResultRequest, {
            query: this.getQuery(),
        });
    }
    startLoader(name) {
        if (this.getLoader()) {
            const loaders = document.querySelectorAll(`.needletail-loader.${name}`);
            loaders.forEach((loader) => {
                loader.classList.add(`needletail-loader-${this.getLoader()}`);
            });
        }
    }
    stopLoader(name) {
        const loaders = document.querySelectorAll(`.needletail-loader.${name}`);
        loaders.forEach((loader) => {
            loader.classList.remove(`needletail-loader-${this.getLoader()}`);
        });
    }
}

var template = "<div class=\"needletail-aggregation-bar\">\n    {{#show_clear_filters_top}}\n        <div class=\"needletail-clear-filters-top\">\n            {{{ clear_filters }}}\n        </div>\n    {{/show_clear_filters_top}}\n    {{#fields}}\n        <div class=\"needletail-aggregation-item\">\n            {{{ . }}}\n        </div>\n    {{/fields}}\n    {{#show_clear_filters_bottom}}\n        <div class=\"needletail-clear-filters-bottom\">\n            {{{ clear_filters }}}\n        </div>\n    {{/show_clear_filters_bottom}}\n</div>";

var clearFiltersTemplate = "<span class=\"needletail-clear-filters {{ hidden }}\">{{{ text }}}</span>";

class AggregationBar extends Widget {
    constructor(options = {}) {
        super(options);
        this.discriminator = 'AggregationBar';
        this.useClearFilters = false;
        this.clearFiltersTop = false;
        this.clearFiltersBottom = false;
        this.clearFiltersText = 'Clear filters';
        this.clearFiltersHideOnNoneActive = true;
        this.useSkeleton = false;
        this.aggregationActives = {};
        this.fields = [];
        this.setUseClearFilters(optional(options.clear_filters).use || this.getUseClearFilters());
        this.setClearFiltersTop(optional(options.clear_filters).top || this.getClearFiltersTop());
        this.setClearFiltersBottom(optional(options.clear_filters).bottom || this.getClearFiltersBottom());
        this.setClearFiltersText(optional(options.clear_filters).text || this.getClearFiltersText());
        this.setClearFiltersHideOnNoneActive(optional(options.clear_filters).hide_on_none_active ||
            this.getClearFiltersHideOnNoneActive());
        this.setUseSkeleton((typeof optional(options).use_skeleton !== 'undefined') ?
            optional(options).use_skeleton : this.getUseSkeleton());
    }
    getUseSkeleton() {
        return this.useSkeleton;
    }
    setUseSkeleton(useSkeleton) {
        this.useSkeleton = useSkeleton;
        return this;
    }
    setUseClearFilters(useClearFilters) {
        this.useClearFilters = useClearFilters;
        return this;
    }
    getUseClearFilters() {
        return this.useClearFilters;
    }
    setClearFiltersTop(clearFiltersTop) {
        this.clearFiltersTop = clearFiltersTop;
        return this;
    }
    getClearFiltersTop() {
        return this.clearFiltersTop;
    }
    setClearFiltersBottom(clearFiltersBottom) {
        this.clearFiltersBottom = clearFiltersBottom;
        return this;
    }
    getClearFiltersBottom() {
        return this.clearFiltersBottom;
    }
    setClearFiltersText(clearFiltersText) {
        this.clearFiltersText = clearFiltersText;
        return this;
    }
    getClearFiltersText() {
        return this.clearFiltersText;
    }
    setClearFiltersHideOnNoneActive(hideOnNoneActive) {
        this.clearFiltersHideOnNoneActive = hideOnNoneActive;
        return this;
    }
    getClearFiltersHideOnNoneActive() {
        return this.clearFiltersHideOnNoneActive;
    }
    addField(field) {
        field.parent = this;
        this.fields.push(field);
        return this;
    }
    addMultipleFields(fields) {
        fields.forEach((field) => {
            field.parent = this;
            this.fields.push(field);
        });
        return this;
    }
    getTemplate() {
        if (this.template) {
            return this.template;
        }
        return template;
    }
    setDiscriminator(discriminator) {
        this.discriminator = discriminator;
        return this;
    }
    getDiscriminator() {
        return this.discriminator;
    }
    render() {
        const template = this.getTemplate();
        const fields = [];
        this.fields.forEach((field) => {
            let renderedField = '';
            if (field.getUseSkeleton()) {
                renderedField = field.renderSkeleton();
            }
            else {
                renderedField = field.render();
            }
            fields.push(renderedField);
        });
        const rendered = Mustache.render(template, {
            fields: fields,
            clear_filters: this.renderClearFilters(),
            show_clear_filters_top: this.getClearFiltersTop(),
            show_clear_filters_bottom: this.getClearFiltersBottom(),
        });
        return document.createRange().createContextualFragment(rendered);
    }
    setClearFiltersTemplate(template) {
        this.clearFiltersTemplate = template;
        return this;
    }
    getClearFiltersTemplate() {
        if (this.clearFiltersTemplate) {
            return this.clearFiltersTemplate;
        }
        return clearFiltersTemplate;
    }
    renderClearFilters() {
        const template = this.getClearFiltersTemplate();
        return Mustache.render(template, {
            text: this.getClearFiltersText(),
            hidden: (this.getClearFiltersHideOnNoneActive()) ? 'needletail-hidden' : '',
        });
    }
    /**
     * Execute the JS for all the added fields
     */
    executeJS() {
        const elements = document.getElementsByClassName('needletail-clear-filters');
        for (let i = 0; i < elements.length; i++) {
            elements[i].addEventListener('click', () => {
                this.fields.forEach((field) => {
                    field.reset();
                });
            });
        }
        document.addEventListener('DOMContentLoaded', () => {
            this.fields.forEach((field) => {
                // Dirty second fix, but works
                setTimeout(() => {
                    field.setDefaultCollapsed(false);
                }, 1000);
            });
            Events.emit(Events.onAggregationValueChange, {
                initial: true,
            });
        });
        document.addEventListener(Events.onAggregationValueChange, (e) => {
            this.aggregationActives[e.detail.name] = e.detail.hasActive;
            const clearFilters = document.getElementsByClassName('needletail-clear-filters');
            let hasShown = false;
            this.fields.forEach((field) => {
                let title = field.getTitle();
                if (field.discriminator === 'Range') {
                    title = field.getTitle() + '[min]';
                }
                if (!hasShown && URIHelper.getSearchParam(title)) {
                    for (let i = 0; i < clearFilters.length; i++) {
                        clearFilters[i].classList.remove('needletail-hidden');
                    }
                    hasShown = true;
                }
            });
            if (!hasShown) {
                for (let i = 0; i < clearFilters.length; i++) {
                    clearFilters[i].classList.add('needletail-hidden');
                }
            }
        });
        this.fields.forEach((field) => {
            field.executeJS();
        });
        Events.emit(Events.aggregationFinished, {
            name: this.getDiscriminator(),
        });
    }
    getValues() {
        return this.fields.reduce((res, field) => {
            if (Object.keys(field.value).length > 0) {
                res.push(field.value);
            }
            return res;
        }, []);
    }
}

export { AggregationBar, AutocompleteBar, Checkbox, Client, Events, GroupedSearchBar, Radio, Result, Slider, Switch, URIHelper };
